/* baobab-window.c generated by valac 0.20.1.4-f5a54, the Vala compiler
 * generated from baobab-window.vala, do not modify */

/* -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/* Baobab - disk usage analyzer
 *
 * Copyright (C) 2012  Ryan Lortie <desrt@desrt.ca>
 * Copyright (C) 2012  Paolo Borelli <pborelli@gnome.org>
 * Copyright (C) 2012  Stefano Facchini <stefano.facchini@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <libgd/gd.h>
#include "egg-list-box.h"
#include "baobab-chart.h"
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include "config.h"


#define BAOBAB_TYPE_WINDOW (baobab_window_get_type ())
#define BAOBAB_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BAOBAB_TYPE_WINDOW, BaobabWindow))
#define BAOBAB_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BAOBAB_TYPE_WINDOW, BaobabWindowClass))
#define BAOBAB_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAOBAB_TYPE_WINDOW))
#define BAOBAB_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BAOBAB_TYPE_WINDOW))
#define BAOBAB_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BAOBAB_TYPE_WINDOW, BaobabWindowClass))

typedef struct _BaobabWindow BaobabWindow;
typedef struct _BaobabWindowClass BaobabWindowClass;
typedef struct _BaobabWindowPrivate BaobabWindowPrivate;

#define BAOBAB_TYPE_LOCATION_LIST (baobab_location_list_get_type ())
#define BAOBAB_LOCATION_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BAOBAB_TYPE_LOCATION_LIST, BaobabLocationList))
#define BAOBAB_LOCATION_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BAOBAB_TYPE_LOCATION_LIST, BaobabLocationListClass))
#define BAOBAB_IS_LOCATION_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAOBAB_TYPE_LOCATION_LIST))
#define BAOBAB_IS_LOCATION_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BAOBAB_TYPE_LOCATION_LIST))
#define BAOBAB_LOCATION_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BAOBAB_TYPE_LOCATION_LIST, BaobabLocationListClass))

typedef struct _BaobabLocationList BaobabLocationList;
typedef struct _BaobabLocationListClass BaobabLocationListClass;

#define BAOBAB_TYPE_LOCATION (baobab_location_get_type ())
#define BAOBAB_LOCATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BAOBAB_TYPE_LOCATION, BaobabLocation))
#define BAOBAB_LOCATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BAOBAB_TYPE_LOCATION, BaobabLocationClass))
#define BAOBAB_IS_LOCATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAOBAB_TYPE_LOCATION))
#define BAOBAB_IS_LOCATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BAOBAB_TYPE_LOCATION))
#define BAOBAB_LOCATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BAOBAB_TYPE_LOCATION, BaobabLocationClass))

typedef struct _BaobabLocation BaobabLocation;
typedef struct _BaobabLocationClass BaobabLocationClass;

#define BAOBAB_WINDOW_TYPE_DND_TARGETS (baobab_window_dnd_targets_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _baobab_location_unref0(var) ((var == NULL) ? NULL : (var = (baobab_location_unref (var), NULL)))

#define BAOBAB_WINDOW_TYPE_ACTION_STATE (baobab_window_action_state_get_type ())
typedef struct _BaobabWindowActionState BaobabWindowActionState;

#define BAOBAB_TYPE_APPLICATION (baobab_application_get_type ())
#define BAOBAB_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BAOBAB_TYPE_APPLICATION, BaobabApplication))
#define BAOBAB_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BAOBAB_TYPE_APPLICATION, BaobabApplicationClass))
#define BAOBAB_IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAOBAB_TYPE_APPLICATION))
#define BAOBAB_IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BAOBAB_TYPE_APPLICATION))
#define BAOBAB_APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BAOBAB_TYPE_APPLICATION, BaobabApplicationClass))

typedef struct _BaobabApplication BaobabApplication;
typedef struct _BaobabApplicationClass BaobabApplicationClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

#define BAOBAB_TYPE_SCANNER (baobab_scanner_get_type ())
#define BAOBAB_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BAOBAB_TYPE_SCANNER, BaobabScanner))
#define BAOBAB_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BAOBAB_TYPE_SCANNER, BaobabScannerClass))
#define BAOBAB_IS_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAOBAB_TYPE_SCANNER))
#define BAOBAB_IS_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BAOBAB_TYPE_SCANNER))
#define BAOBAB_SCANNER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BAOBAB_TYPE_SCANNER, BaobabScannerClass))

typedef struct _BaobabScanner BaobabScanner;
typedef struct _BaobabScannerClass BaobabScannerClass;
typedef struct _Block1Data Block1Data;

#define BAOBAB_TYPE_CONNECT_SERVER (baobab_connect_server_get_type ())
#define BAOBAB_CONNECT_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BAOBAB_TYPE_CONNECT_SERVER, BaobabConnectServer))
#define BAOBAB_CONNECT_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BAOBAB_TYPE_CONNECT_SERVER, BaobabConnectServerClass))
#define BAOBAB_IS_CONNECT_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAOBAB_TYPE_CONNECT_SERVER))
#define BAOBAB_IS_CONNECT_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BAOBAB_TYPE_CONNECT_SERVER))
#define BAOBAB_CONNECT_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BAOBAB_TYPE_CONNECT_SERVER, BaobabConnectServerClass))

typedef struct _BaobabConnectServer BaobabConnectServer;
typedef struct _BaobabConnectServerClass BaobabConnectServerClass;
typedef struct _Block2Data Block2Data;
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
typedef struct _Block3Data Block3Data;

#define BAOBAB_SCANNER_TYPE_COLUMNS (baobab_scanner_columns_get_type ())
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block4Data Block4Data;

struct _BaobabWindow {
	GtkApplicationWindow parent_instance;
	BaobabWindowPrivate * priv;
};

struct _BaobabWindowClass {
	GtkApplicationWindowClass parent_class;
};

struct _BaobabWindowPrivate {
	GSettings* ui_settings;
	GdHeaderBar* header_bar;
	GdHeaderBar* result_header_bar;
	GdStack* main_stack;
	GtkWidget* home_page;
	GtkWidget* result_page;
	GtkInfoBar* infobar;
	GtkLabel* infobar_primary;
	GtkLabel* infobar_secondary;
	GtkScrolledWindow* location_scroll;
	BaobabLocationList* location_list;
	GtkTreeView* treeview;
	GdStack* chart_stack;
	BaobabChart* rings_chart;
	BaobabChart* treemap_chart;
	GtkSpinner* spinner;
	BaobabLocation* active_location;
	gulong scan_completed_handler;
};

typedef enum  {
	BAOBAB_WINDOW_DND_TARGETS_URI_LIST
} BaobabWindowDndTargets;

struct _BaobabWindowActionState {
	gchar* name;
	gboolean enable;
};

typedef void (*BaobabLocationListLocationAction) (BaobabLocation* l, void* user_data);
struct _Block1Data {
	int _ref_count_;
	BaobabWindow * self;
	GtkFileChooserDialog* file_chooser;
};

struct _Block2Data {
	int _ref_count_;
	BaobabWindow * self;
	BaobabLocation* location;
};

struct _Block3Data {
	int _ref_count_;
	BaobabWindow * self;
	GtkMenu* popup;
	GtkTreeSelection* selection;
};

typedef enum  {
	BAOBAB_SCANNER_COLUMNS_DISPLAY_NAME,
	BAOBAB_SCANNER_COLUMNS_PARSE_NAME,
	BAOBAB_SCANNER_COLUMNS_PERCENT,
	BAOBAB_SCANNER_COLUMNS_SIZE,
	BAOBAB_SCANNER_COLUMNS_ALLOC_SIZE,
	BAOBAB_SCANNER_COLUMNS_ELEMENTS,
	BAOBAB_SCANNER_COLUMNS_STATE,
	BAOBAB_SCANNER_COLUMNS_ERROR,
	BAOBAB_SCANNER_COLUMNS_COLUMNS
} BaobabScannerColumns;

struct _Block4Data {
	int _ref_count_;
	BaobabWindow * self;
	BaobabScanner* scanner;
};


static gpointer baobab_window_parent_class = NULL;
static GdkCursor* baobab_window_busy_cursor;
static GdkCursor* baobab_window_busy_cursor = NULL;

GType baobab_window_get_type (void) G_GNUC_CONST;
GType baobab_location_list_get_type (void) G_GNUC_CONST;
gpointer baobab_location_ref (gpointer instance);
void baobab_location_unref (gpointer instance);
GParamSpec* baobab_param_spec_location (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void baobab_value_set_location (GValue* value, gpointer v_object);
void baobab_value_take_location (GValue* value, gpointer v_object);
gpointer baobab_value_get_location (const GValue* value);
GType baobab_location_get_type (void) G_GNUC_CONST;
#define BAOBAB_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), BAOBAB_TYPE_WINDOW, BaobabWindowPrivate))
enum  {
	BAOBAB_WINDOW_DUMMY_PROPERTY
};
static GType baobab_window_dnd_targets_get_type (void) G_GNUC_UNUSED;
static void baobab_window_on_show_gear_menu_activate (BaobabWindow* self, GSimpleAction* action);
static void _baobab_window_on_show_gear_menu_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_show_home_page_activate (BaobabWindow* self);
static void _baobab_window_on_show_home_page_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_radio_activate (BaobabWindow* self, GSimpleAction* action, GVariant* parameter);
static void _baobab_window_radio_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_chart_type_changed (BaobabWindow* self, GSimpleAction* action, GVariant* value);
static void _baobab_window_on_chart_type_changed_gsimple_action_change_state_callback (GSimpleAction* action, GVariant* value, gpointer self);
static void baobab_window_on_scan_home_activate (BaobabWindow* self);
static void _baobab_window_on_scan_home_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_scan_folder_activate (BaobabWindow* self);
static void _baobab_window_on_scan_folder_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_scan_remote_activate (BaobabWindow* self);
static void _baobab_window_on_scan_remote_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_reload_activate (BaobabWindow* self);
static void _baobab_window_on_reload_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_show_allocated (BaobabWindow* self);
static void _baobab_window_on_show_allocated_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_expand_all (BaobabWindow* self);
static void _baobab_window_on_expand_all_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_collapse_all (BaobabWindow* self);
static void _baobab_window_on_collapse_all_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_help_activate (BaobabWindow* self);
static void _baobab_window_on_help_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void baobab_window_on_about_activate (BaobabWindow* self);
static void _baobab_window_on_about_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
GType baobab_window_action_state_get_type (void) G_GNUC_CONST;
BaobabWindowActionState* baobab_window_action_state_dup (const BaobabWindowActionState* self);
void baobab_window_action_state_free (BaobabWindowActionState* self);
void baobab_window_action_state_copy (const BaobabWindowActionState* self, BaobabWindowActionState* dest);
void baobab_window_action_state_destroy (BaobabWindowActionState* self);
GType baobab_application_get_type (void) G_GNUC_CONST;
BaobabWindow* baobab_window_new (BaobabApplication* app);
BaobabWindow* baobab_window_construct (GType object_type, BaobabApplication* app);
void baobab_location_list_set_action (BaobabLocationList* self, BaobabLocationListLocationAction action, void* action_target, GDestroyNotify action_target_destroy_notify);
static void baobab_window_on_scan_location_activate (BaobabWindow* self, BaobabLocation* location);
static void _baobab_window_on_scan_location_activate_baobab_location_list_location_action (BaobabLocation* l, gpointer self);
void baobab_location_list_update (BaobabLocationList* self);
gboolean baobab_connect_server_available (void);
static void baobab_window_setup_treeview (BaobabWindow* self, GtkBuilder* builder);
static void __lambda15_ (BaobabWindow* self);
static void baobab_window_clear_message (BaobabWindow* self);
static void ___lambda15__gtk_button_clicked (GtkButton* _sender, gpointer self);
GSettings* baobab_application_get_ui_settings (void);
static void baobab_window_on_chart_item_activated (BaobabWindow* self, BaobabChart* chart, GtkTreeIter* iter);
static void _baobab_window_on_chart_item_activated_baobab_chart_item_activated (BaobabChart* _sender, GtkTreeIter* iter, gpointer self);
static void baobab_window_on_drag_data_received (BaobabWindow* self, GtkWidget* widget, GdkDragContext* context, gint x, gint y, GtkSelectionData* selection_data, guint target_type, guint time);
static void _baobab_window_on_drag_data_received_gtk_widget_drag_data_received (GtkWidget* _sender, GdkDragContext* context, gint x, gint y, GtkSelectionData* selection_data, guint info, guint time_, gpointer self);
static void baobab_window_enable_drop (BaobabWindow* self);
static gboolean __lambda16_ (BaobabWindow* self, GdkEventWindowState* event);
static gboolean ___lambda16__gtk_widget_window_state_event (GtkWidget* _sender, GdkEventWindowState* event, gpointer self);
static gboolean __lambda17_ (BaobabWindow* self, GdkEventConfigure* event);
static gboolean ___lambda17__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
static void baobab_window_set_ui_state (BaobabWindow* self, GtkWidget* child, gboolean busy);
GType baobab_scanner_get_type (void) G_GNUC_CONST;
BaobabScanner* baobab_location_get_scanner (BaobabLocation* self);
void baobab_scanner_cancel (BaobabScanner* self);
static gchar* _variant_get2 (GVariant* value);
void baobab_window_scan_directory (BaobabWindow* self, GFile* directory);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda6_ (Block1Data* _data1_, gint response);
static void ___lambda6__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
BaobabConnectServer* baobab_connect_server_new (void);
BaobabConnectServer* baobab_connect_server_construct (GType object_type);
GType baobab_connect_server_get_type (void) G_GNUC_CONST;
static void __lambda7_ (BaobabWindow* self, const gchar* uri);
static void ___lambda7__baobab_connect_server_selected (BaobabConnectServer* _sender, const gchar* uri, gpointer self);
void baobab_connect_server_show (BaobabConnectServer* self);
static void baobab_window_set_active_location (BaobabWindow* self, BaobabLocation* location);
void baobab_location_list_add_location (BaobabLocationList* self, BaobabLocation* location);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
gboolean baobab_location_get_is_volume (BaobabLocation* self);
void baobab_location_mount_volume (BaobabLocation* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void baobab_location_mount_volume_finish (BaobabLocation* self, GAsyncResult* _res_, GError** error);
static void ___lambda8_ (Block2Data* _data2_, GObject* location_, GAsyncResult* res);
static void baobab_window_scan_active_location (BaobabWindow* self, gboolean force);
static void baobab_window_message (BaobabWindow* self, const gchar* primary_msg, const gchar* secondary_msg, GtkMessageType type);
static void ____lambda8__gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
static void baobab_window_disable_drop (BaobabWindow* self);
static gboolean baobab_window_show_treeview_popup (BaobabWindow* self, GtkMenu* popup, GdkEventButton* event);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static gboolean __lambda9_ (Block3Data* _data3_, GdkEventButton* event);
static gboolean ___lambda9__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean __lambda10_ (Block3Data* _data3_);
static gboolean ___lambda10__gtk_widget_popup_menu (GtkWidget* _sender, gpointer self);
static void __lambda11_ (BaobabWindow* self);
GType baobab_scanner_columns_get_type (void) G_GNUC_CONST;
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static void ___lambda11__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda12_ (BaobabWindow* self);
static void ___lambda12__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda13_ (BaobabWindow* self);
static void ___lambda13__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda14_ (Block3Data* _data3_);
static void ___lambda14__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
static void baobab_window_set_busy (BaobabWindow* self, gboolean busy);
const gchar* baobab_location_get_name (BaobabLocation* self);
static void baobab_window_first_row_has_child (BaobabWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter);
static void _baobab_window_first_row_has_child_gtk_tree_model_row_has_child_toggled (GtkTreeModel* _sender, GtkTreePath* path, GtkTreeIter* iter, gpointer self);
static void baobab_window_expand_first_row (BaobabWindow* self);
static void baobab_window_set_model (BaobabWindow* self, GtkTreeModel* model);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static void __lambda5_ (Block4Data* _data4_);
void baobab_scanner_finish (BaobabScanner* self, GError** error);
GFile* baobab_scanner_get_directory (BaobabScanner* self);
static void ___lambda5__baobab_scanner_completed (BaobabScanner* _sender, gpointer self);
void baobab_scanner_scan (BaobabScanner* self, gboolean force);
BaobabLocation* baobab_location_new_for_file (GFile* file_);
BaobabLocation* baobab_location_construct_for_file (GType object_type, GFile* file_);
GFileInfo* baobab_location_get_info (BaobabLocation* self);
static void baobab_window_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const GActionEntry BAOBAB_WINDOW_action_entries[12] = {{"gear-menu", _baobab_window_on_show_gear_menu_activate_gsimple_action_activate_callback, NULL, "false", NULL}, {"show-home-page", _baobab_window_on_show_home_page_activate_gsimple_action_activate_callback}, {"active-chart", _baobab_window_radio_activate_gsimple_action_activate_callback, "s", "'rings'", _baobab_window_on_chart_type_changed_gsimple_action_change_state_callback}, {"scan-home", _baobab_window_on_scan_home_activate_gsimple_action_activate_callback}, {"scan-folder", _baobab_window_on_scan_folder_activate_gsimple_action_activate_callback}, {"scan-remote", _baobab_window_on_scan_remote_activate_gsimple_action_activate_callback}, {"reload", _baobab_window_on_reload_activate_gsimple_action_activate_callback}, {"show-allocated", _baobab_window_on_show_allocated_gsimple_action_activate_callback}, {"expand-all", _baobab_window_on_expand_all_gsimple_action_activate_callback}, {"collapse-all", _baobab_window_on_collapse_all_gsimple_action_activate_callback}, {"help", _baobab_window_on_help_activate_gsimple_action_activate_callback}, {"about", _baobab_window_on_about_activate_gsimple_action_activate_callback}};
static const BaobabWindowActionState BAOBAB_WINDOW_actions_while_scanning[6] = {{"scan-home", FALSE}, {"scan-folder", FALSE}, {"scan-remote", FALSE}, {"show-allocated", FALSE}, {"expand-all", FALSE}, {"collapse-all", FALSE}};
static const GtkTargetEntry BAOBAB_WINDOW_dnd_target_list[1] = {{"text/uri-list", (guint) 0, (guint) BAOBAB_WINDOW_DND_TARGETS_URI_LIST}};

static GType baobab_window_dnd_targets_get_type (void) {
	static volatile gsize baobab_window_dnd_targets_type_id__volatile = 0;
	if (g_once_init_enter (&baobab_window_dnd_targets_type_id__volatile)) {
		static const GEnumValue values[] = {{BAOBAB_WINDOW_DND_TARGETS_URI_LIST, "BAOBAB_WINDOW_DND_TARGETS_URI_LIST", "uri-list"}, {0, NULL, NULL}};
		GType baobab_window_dnd_targets_type_id;
		baobab_window_dnd_targets_type_id = g_enum_register_static ("BaobabWindowDndTargets", values);
		g_once_init_leave (&baobab_window_dnd_targets_type_id__volatile, baobab_window_dnd_targets_type_id);
	}
	return baobab_window_dnd_targets_type_id__volatile;
}


static void _baobab_window_on_show_gear_menu_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_show_gear_menu_activate (self, action);
}


static void _baobab_window_on_show_home_page_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_show_home_page_activate (self);
}


static void _baobab_window_radio_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_radio_activate (self, action, parameter);
}


static void _baobab_window_on_chart_type_changed_gsimple_action_change_state_callback (GSimpleAction* action, GVariant* value, gpointer self) {
	baobab_window_on_chart_type_changed (self, action, value);
}


static void _baobab_window_on_scan_home_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_scan_home_activate (self);
}


static void _baobab_window_on_scan_folder_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_scan_folder_activate (self);
}


static void _baobab_window_on_scan_remote_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_scan_remote_activate (self);
}


static void _baobab_window_on_reload_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_reload_activate (self);
}


static void _baobab_window_on_show_allocated_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_show_allocated (self);
}


static void _baobab_window_on_expand_all_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_expand_all (self);
}


static void _baobab_window_on_collapse_all_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_collapse_all (self);
}


static void _baobab_window_on_help_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_help_activate (self);
}


static void _baobab_window_on_about_activate_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	baobab_window_on_about_activate (self);
}


static void baobab_window_radio_activate (BaobabWindow* self, GSimpleAction* action, GVariant* parameter) {
	GSimpleAction* _tmp0_;
	GVariant* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = parameter;
	g_signal_emit_by_name (_tmp0_, "change-state", _tmp1_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _baobab_window_on_scan_location_activate_baobab_location_list_location_action (BaobabLocation* l, gpointer self) {
	baobab_window_on_scan_location_activate (self, l);
}


static void __lambda15_ (BaobabWindow* self) {
	baobab_window_clear_message (self);
}


static void ___lambda15__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda15_ (self);
}


static void _baobab_window_on_chart_item_activated_baobab_chart_item_activated (BaobabChart* _sender, GtkTreeIter* iter, gpointer self) {
	baobab_window_on_chart_item_activated (self, _sender, iter);
}


static void _baobab_window_on_drag_data_received_gtk_widget_drag_data_received (GtkWidget* _sender, GdkDragContext* context, gint x, gint y, GtkSelectionData* selection_data, guint info, guint time_, gpointer self) {
	baobab_window_on_drag_data_received (self, _sender, context, x, y, selection_data, info, time_);
}


static gboolean __lambda16_ (BaobabWindow* self, GdkEventWindowState* event) {
	gboolean result = FALSE;
	GSettings* _tmp0_;
	GdkEventWindowState _tmp1_;
	GdkWindowState _tmp2_;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->ui_settings;
	_tmp1_ = *event;
	_tmp2_ = _tmp1_.new_window_state;
	g_settings_set_int (_tmp0_, "window-state", (gint) _tmp2_);
	result = FALSE;
	return result;
}


static gboolean ___lambda16__gtk_widget_window_state_event (GtkWidget* _sender, GdkEventWindowState* event, gpointer self) {
	gboolean result;
	result = __lambda16_ (self, event);
	return result;
}


static gboolean __lambda17_ (BaobabWindow* self, GdkEventConfigure* event) {
	gboolean result = FALSE;
	GdkWindow* _tmp0_ = NULL;
	GdkWindowState _tmp1_ = 0;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = gdk_window_get_state (_tmp0_);
	if (!((_tmp1_ & GDK_WINDOW_STATE_MAXIMIZED) == GDK_WINDOW_STATE_MAXIMIZED)) {
		GSettings* _tmp2_;
		GdkEventConfigure _tmp3_;
		gint _tmp4_;
		GdkEventConfigure _tmp5_;
		gint _tmp6_;
		_tmp2_ = self->priv->ui_settings;
		_tmp3_ = *event;
		_tmp4_ = _tmp3_.width;
		_tmp5_ = *event;
		_tmp6_ = _tmp5_.height;
		g_settings_set (_tmp2_, "window-size", "(ii)", _tmp4_, _tmp6_);
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda17__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = __lambda17_ (self, event);
	return result;
}


BaobabWindow* baobab_window_construct (GType object_type, BaobabApplication* app) {
	BaobabWindow * self = NULL;
	BaobabApplication* _tmp0_;
	GdkCursor* _tmp1_;
	GtkBuilder* _tmp3_;
	GtkBuilder* builder;
	GObject* _tmp5_ = NULL;
	GdStack* _tmp6_;
	GObject* _tmp7_ = NULL;
	GtkWidget* _tmp8_;
	GObject* _tmp9_ = NULL;
	GtkWidget* _tmp10_;
	GObject* _tmp11_ = NULL;
	GdHeaderBar* _tmp12_;
	GObject* _tmp13_ = NULL;
	GdHeaderBar* _tmp14_;
	GObject* _tmp15_ = NULL;
	GtkInfoBar* _tmp16_;
	GObject* _tmp17_ = NULL;
	GtkLabel* _tmp18_;
	GObject* _tmp19_ = NULL;
	GtkLabel* _tmp20_;
	GObject* _tmp21_ = NULL;
	GtkScrolledWindow* _tmp22_;
	GObject* _tmp23_ = NULL;
	BaobabLocationList* _tmp24_;
	GObject* _tmp25_ = NULL;
	GtkTreeView* _tmp26_;
	GObject* _tmp27_ = NULL;
	GdStack* _tmp28_;
	GObject* _tmp29_ = NULL;
	BaobabChart* _tmp30_;
	GObject* _tmp31_ = NULL;
	BaobabChart* _tmp32_;
	GObject* _tmp33_ = NULL;
	GtkSpinner* _tmp34_;
	BaobabLocationList* _tmp35_;
	GtkScrolledWindow* _tmp36_;
	GtkAdjustment* _tmp37_ = NULL;
	BaobabLocationList* _tmp38_;
	BaobabLocationList* _tmp39_;
	GAction* _tmp40_ = NULL;
	GSimpleAction* _tmp41_;
	GSimpleAction* action;
	GSimpleAction* _tmp42_;
	gboolean _tmp43_ = FALSE;
	GObject* _tmp44_ = NULL;
	GtkButton* _tmp45_;
	GtkButton* infobar_close_button;
	GtkButton* _tmp46_;
	GSettings* _tmp47_ = NULL;
	GAction* _tmp48_ = NULL;
	GSettings* _tmp49_;
	GVariant* _tmp50_ = NULL;
	GVariant* _tmp51_;
	BaobabChart* _tmp52_;
	BaobabChart* _tmp53_;
	GSettings* _tmp54_;
	gint _tmp55_ = 0;
	GdkWindowState window_state;
	GdkWindowState _tmp56_;
	gint width = 0;
	gint height = 0;
	GSettings* _tmp57_;
	GObject* _tmp58_ = NULL;
	const gchar* _tmp59_ = NULL;
	GtkWidget* _tmp60_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (app != NULL, NULL);
	_tmp0_ = app;
	self = (BaobabWindow*) g_object_new (object_type, "application", _tmp0_, NULL);
	_tmp1_ = baobab_window_busy_cursor;
	if (_tmp1_ == NULL) {
		GdkCursor* _tmp2_;
		_tmp2_ = gdk_cursor_new (GDK_WATCH);
		_g_object_unref0 (baobab_window_busy_cursor);
		baobab_window_busy_cursor = _tmp2_;
	}
	g_action_map_add_action_entries ((GActionMap*) self, (const GActionEntry*) BAOBAB_WINDOW_action_entries, G_N_ELEMENTS (BAOBAB_WINDOW_action_entries), self);
	_tmp3_ = gtk_builder_new ();
	builder = _tmp3_;
	{
		gtk_builder_add_from_resource (builder, "/org/gnome/baobab/ui/baobab-main-window.ui", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch9_g_error;
		}
	}
	goto __finally9;
	__catch9_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp4_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e->message;
		g_error ("baobab-window.vala:102: loading main builder file: %s", _tmp4_);
		_g_error_free0 (e);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (builder);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp5_ = gtk_builder_get_object (builder, "main-stack");
	_tmp6_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, gd_stack_get_type ()) ? ((GdStack*) _tmp5_) : NULL);
	_g_object_unref0 (self->priv->main_stack);
	self->priv->main_stack = _tmp6_;
	_tmp7_ = gtk_builder_get_object (builder, "home-page");
	_tmp8_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp7_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp7_) : NULL);
	_g_object_unref0 (self->priv->home_page);
	self->priv->home_page = _tmp8_;
	_tmp9_ = gtk_builder_get_object (builder, "result-page");
	_tmp10_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp9_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp9_) : NULL);
	_g_object_unref0 (self->priv->result_page);
	self->priv->result_page = _tmp10_;
	_tmp11_ = gtk_builder_get_object (builder, "header-bar");
	_tmp12_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp11_, gd_header_bar_get_type ()) ? ((GdHeaderBar*) _tmp11_) : NULL);
	_g_object_unref0 (self->priv->header_bar);
	self->priv->header_bar = _tmp12_;
	_tmp13_ = gtk_builder_get_object (builder, "result-header-bar");
	_tmp14_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp13_, gd_header_bar_get_type ()) ? ((GdHeaderBar*) _tmp13_) : NULL);
	_g_object_unref0 (self->priv->result_header_bar);
	self->priv->result_header_bar = _tmp14_;
	_tmp15_ = gtk_builder_get_object (builder, "infobar");
	_tmp16_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp15_, GTK_TYPE_INFO_BAR) ? ((GtkInfoBar*) _tmp15_) : NULL);
	_g_object_unref0 (self->priv->infobar);
	self->priv->infobar = _tmp16_;
	_tmp17_ = gtk_builder_get_object (builder, "infobar-primary-label");
	_tmp18_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp17_, GTK_TYPE_LABEL) ? ((GtkLabel*) _tmp17_) : NULL);
	_g_object_unref0 (self->priv->infobar_primary);
	self->priv->infobar_primary = _tmp18_;
	_tmp19_ = gtk_builder_get_object (builder, "infobar-secondary-label");
	_tmp20_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp19_, GTK_TYPE_LABEL) ? ((GtkLabel*) _tmp19_) : NULL);
	_g_object_unref0 (self->priv->infobar_secondary);
	self->priv->infobar_secondary = _tmp20_;
	_tmp21_ = gtk_builder_get_object (builder, "location-scrolled-window");
	_tmp22_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp21_, GTK_TYPE_SCROLLED_WINDOW) ? ((GtkScrolledWindow*) _tmp21_) : NULL);
	_g_object_unref0 (self->priv->location_scroll);
	self->priv->location_scroll = _tmp22_;
	_tmp23_ = gtk_builder_get_object (builder, "location-list");
	_tmp24_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp23_, BAOBAB_TYPE_LOCATION_LIST) ? ((BaobabLocationList*) _tmp23_) : NULL);
	_g_object_unref0 (self->priv->location_list);
	self->priv->location_list = _tmp24_;
	_tmp25_ = gtk_builder_get_object (builder, "treeview");
	_tmp26_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp25_, GTK_TYPE_TREE_VIEW) ? ((GtkTreeView*) _tmp25_) : NULL);
	_g_object_unref0 (self->priv->treeview);
	self->priv->treeview = _tmp26_;
	_tmp27_ = gtk_builder_get_object (builder, "chart-stack");
	_tmp28_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp27_, gd_stack_get_type ()) ? ((GdStack*) _tmp27_) : NULL);
	_g_object_unref0 (self->priv->chart_stack);
	self->priv->chart_stack = _tmp28_;
	_tmp29_ = gtk_builder_get_object (builder, "rings-chart");
	_tmp30_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp29_, BAOBAB_TYPE_CHART) ? ((BaobabChart*) _tmp29_) : NULL);
	_g_object_unref0 (self->priv->rings_chart);
	self->priv->rings_chart = _tmp30_;
	_tmp31_ = gtk_builder_get_object (builder, "treemap-chart");
	_tmp32_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp31_, BAOBAB_TYPE_CHART) ? ((BaobabChart*) _tmp31_) : NULL);
	_g_object_unref0 (self->priv->treemap_chart);
	self->priv->treemap_chart = _tmp32_;
	_tmp33_ = gtk_builder_get_object (builder, "spinner");
	_tmp34_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp33_, GTK_TYPE_SPINNER) ? ((GtkSpinner*) _tmp33_) : NULL);
	_g_object_unref0 (self->priv->spinner);
	self->priv->spinner = _tmp34_;
	_tmp35_ = self->priv->location_list;
	_tmp36_ = self->priv->location_scroll;
	_tmp37_ = gtk_scrolled_window_get_vadjustment (_tmp36_);
	egg_list_box_set_adjustment ((EggListBox*) _tmp35_, _tmp37_);
	_tmp38_ = self->priv->location_list;
	baobab_location_list_set_action (_tmp38_, _baobab_window_on_scan_location_activate_baobab_location_list_location_action, g_object_ref (self), g_object_unref);
	_tmp39_ = self->priv->location_list;
	baobab_location_list_update (_tmp39_);
	_tmp40_ = g_action_map_lookup_action ((GActionMap*) self, "scan-remote");
	_tmp41_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp40_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp40_) : NULL);
	action = _tmp41_;
	_tmp42_ = action;
	_tmp43_ = baobab_connect_server_available ();
	g_simple_action_set_enabled (_tmp42_, _tmp43_);
	baobab_window_setup_treeview (self, builder);
	_tmp44_ = gtk_builder_get_object (builder, "infobar-close-button");
	_tmp45_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp44_, GTK_TYPE_BUTTON) ? ((GtkButton*) _tmp44_) : NULL);
	infobar_close_button = _tmp45_;
	_tmp46_ = infobar_close_button;
	g_signal_connect_object (_tmp46_, "clicked", (GCallback) ___lambda15__gtk_button_clicked, self, 0);
	_tmp47_ = baobab_application_get_ui_settings ();
	_g_object_unref0 (self->priv->ui_settings);
	self->priv->ui_settings = _tmp47_;
	_tmp48_ = g_action_map_lookup_action ((GActionMap*) self, "active-chart");
	_tmp49_ = self->priv->ui_settings;
	_tmp50_ = g_settings_get_value (_tmp49_, "active-chart");
	_tmp51_ = _tmp50_;
	g_action_change_state (_tmp48_, _tmp51_);
	_g_variant_unref0 (_tmp51_);
	_tmp52_ = self->priv->rings_chart;
	g_signal_connect_object (_tmp52_, "item-activated", (GCallback) _baobab_window_on_chart_item_activated_baobab_chart_item_activated, self, 0);
	_tmp53_ = self->priv->treemap_chart;
	g_signal_connect_object (_tmp53_, "item-activated", (GCallback) _baobab_window_on_chart_item_activated_baobab_chart_item_activated, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "drag-data-received", (GCallback) _baobab_window_on_drag_data_received_gtk_widget_drag_data_received, self, 0);
	baobab_window_enable_drop (self);
	_tmp54_ = self->priv->ui_settings;
	_tmp55_ = g_settings_get_int (_tmp54_, "window-state");
	window_state = (GdkWindowState) _tmp55_;
	_tmp56_ = window_state;
	if ((_tmp56_ & GDK_WINDOW_STATE_MAXIMIZED) == GDK_WINDOW_STATE_MAXIMIZED) {
		gtk_window_maximize ((GtkWindow*) self);
	}
	_tmp57_ = self->priv->ui_settings;
	g_settings_get (_tmp57_, "window-size", "(ii)", &width, &height);
	gtk_window_resize ((GtkWindow*) self, width, height);
	g_signal_connect_object ((GtkWidget*) self, "window-state-event", (GCallback) ___lambda16__gtk_widget_window_state_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "configure-event", (GCallback) ___lambda17__gtk_widget_configure_event, self, 0);
	_tmp58_ = gtk_builder_get_object (builder, "window-contents");
	gtk_container_add ((GtkContainer*) self, G_TYPE_CHECK_INSTANCE_TYPE (_tmp58_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp58_) : NULL);
	_tmp59_ = _ ("Disk Usage Analyzer");
	gtk_window_set_title ((GtkWindow*) self, _tmp59_);
	gtk_window_set_hide_titlebar_when_maximized ((GtkWindow*) self, TRUE);
	_baobab_location_unref0 (self->priv->active_location);
	self->priv->active_location = NULL;
	self->priv->scan_completed_handler = (gulong) 0;
	_tmp60_ = self->priv->home_page;
	baobab_window_set_ui_state (self, _tmp60_, FALSE);
	gtk_widget_show ((GtkWidget*) self);
	_g_object_unref0 (infobar_close_button);
	_g_object_unref0 (action);
	_g_object_unref0 (builder);
	return self;
}


BaobabWindow* baobab_window_new (BaobabApplication* app) {
	return baobab_window_construct (BAOBAB_TYPE_WINDOW, app);
}


static void baobab_window_on_show_gear_menu_activate (BaobabWindow* self, GSimpleAction* action) {
	GSimpleAction* _tmp0_;
	GVariant* _tmp1_ = NULL;
	GVariant* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_;
	gboolean state;
	GSimpleAction* _tmp5_;
	GVariant* _tmp6_;
	GVariant* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = g_action_get_state ((GAction*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_variant_get_boolean (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_variant_unref0 (_tmp2_);
	state = _tmp4_;
	_tmp5_ = action;
	_tmp6_ = g_variant_new_boolean (!state);
	g_variant_ref_sink (_tmp6_);
	_tmp7_ = _tmp6_;
	g_simple_action_set_state (_tmp5_, _tmp7_);
	_g_variant_unref0 (_tmp7_);
}


static void baobab_window_on_show_home_page_activate (BaobabWindow* self) {
	gboolean _tmp0_ = FALSE;
	BaobabLocation* _tmp1_;
	gboolean _tmp5_;
	GtkWidget* _tmp9_;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->priv->active_location;
	if (_tmp1_ != NULL) {
		BaobabLocation* _tmp2_;
		BaobabScanner* _tmp3_;
		BaobabScanner* _tmp4_;
		_tmp2_ = self->priv->active_location;
		_tmp3_ = baobab_location_get_scanner (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		BaobabLocation* _tmp6_;
		BaobabScanner* _tmp7_;
		BaobabScanner* _tmp8_;
		_tmp6_ = self->priv->active_location;
		_tmp7_ = baobab_location_get_scanner (_tmp6_);
		_tmp8_ = _tmp7_;
		baobab_scanner_cancel (_tmp8_);
	}
	baobab_window_clear_message (self);
	_tmp9_ = self->priv->home_page;
	baobab_window_set_ui_state (self, _tmp9_, FALSE);
}


static gchar* _variant_get2 (GVariant* value) {
	return g_variant_dup_string (value, NULL);
}


static void baobab_window_on_chart_type_changed (BaobabWindow* self, GSimpleAction* action, GVariant* value) {
	GVariant* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	GQuark _tmp4_ = 0U;
	static GQuark _tmp3_label0 = 0;
	static GQuark _tmp3_label1 = 0;
	GSettings* _tmp9_;
	GVariant* _tmp10_;
	GSimpleAction* _tmp11_;
	GVariant* _tmp12_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = value;
	_tmp1_ = _variant_get2 (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp4_ = (NULL == _tmp2_) ? 0 : g_quark_from_string (_tmp2_);
	g_free (_tmp2_);
	if (_tmp4_ == ((0 != _tmp3_label0) ? _tmp3_label0 : (_tmp3_label0 = g_quark_from_static_string ("rings")))) {
		switch (0) {
			default:
			{
				GdStack* _tmp5_;
				BaobabChart* _tmp6_;
				_tmp5_ = self->priv->chart_stack;
				_tmp6_ = self->priv->rings_chart;
				gd_stack_set_visible_child (_tmp5_, (GtkWidget*) _tmp6_);
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label1) ? _tmp3_label1 : (_tmp3_label1 = g_quark_from_static_string ("treemap")))) {
		switch (0) {
			default:
			{
				GdStack* _tmp7_;
				BaobabChart* _tmp8_;
				_tmp7_ = self->priv->chart_stack;
				_tmp8_ = self->priv->treemap_chart;
				gd_stack_set_visible_child (_tmp7_, (GtkWidget*) _tmp8_);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				return;
			}
		}
	}
	_tmp9_ = self->priv->ui_settings;
	_tmp10_ = value;
	g_settings_set_value (_tmp9_, "active-chart", _tmp10_);
	_tmp11_ = action;
	_tmp12_ = value;
	g_simple_action_set_state (_tmp11_, _tmp12_);
}


static void baobab_window_on_scan_home_activate (BaobabWindow* self) {
	const gchar* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFile* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_get_home_dir ();
	_tmp1_ = g_file_new_for_path (_tmp0_);
	_tmp2_ = _tmp1_;
	baobab_window_scan_directory (self, _tmp2_);
	_g_object_unref0 (_tmp2_);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		BaobabWindow * self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->file_chooser);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void __lambda6_ (Block1Data* _data1_, gint response) {
	BaobabWindow * self;
	gint _tmp0_;
	self = _data1_->self;
	_tmp0_ = response;
	if (_tmp0_ == ((gint) GTK_RESPONSE_ACCEPT)) {
		GFile* _tmp1_ = NULL;
		_tmp1_ = gtk_file_chooser_get_file ((GtkFileChooser*) _data1_->file_chooser);
		baobab_window_scan_directory (self, _tmp1_);
	}
	gtk_widget_destroy ((GtkWidget*) _data1_->file_chooser);
}


static void ___lambda6__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	__lambda6_ (self, response_id);
}


static void baobab_window_on_scan_folder_activate (BaobabWindow* self) {
	Block1Data* _data1_;
	const gchar* _tmp0_ = NULL;
	GtkFileChooserDialog* _tmp1_;
	g_return_if_fail (self != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = _ ("Select Folder");
	_tmp1_ = (GtkFileChooserDialog*) gtk_file_chooser_dialog_new (_tmp0_, (GtkWindow*) self, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
	g_object_ref_sink (_tmp1_);
	_data1_->file_chooser = _tmp1_;
	gtk_window_set_modal ((GtkWindow*) _data1_->file_chooser, TRUE);
	g_signal_connect_data ((GtkDialog*) _data1_->file_chooser, "response", (GCallback) ___lambda6__gtk_dialog_response, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	gtk_widget_show ((GtkWidget*) _data1_->file_chooser);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


static void __lambda7_ (BaobabWindow* self, const gchar* uri) {
	const gchar* _tmp0_;
	_tmp0_ = uri;
	if (_tmp0_ != NULL) {
		const gchar* _tmp1_;
		GFile* _tmp2_ = NULL;
		GFile* _tmp3_;
		_tmp1_ = uri;
		_tmp2_ = g_file_new_for_uri (_tmp1_);
		_tmp3_ = _tmp2_;
		baobab_window_scan_directory (self, _tmp3_);
		_g_object_unref0 (_tmp3_);
	}
}


static void ___lambda7__baobab_connect_server_selected (BaobabConnectServer* _sender, const gchar* uri, gpointer self) {
	__lambda7_ (self, uri);
}


static void baobab_window_on_scan_remote_activate (BaobabWindow* self) {
	BaobabConnectServer* _tmp0_;
	BaobabConnectServer* connect_server;
	g_return_if_fail (self != NULL);
	_tmp0_ = baobab_connect_server_new ();
	connect_server = _tmp0_;
	g_signal_connect_object (connect_server, "selected", (GCallback) ___lambda7__baobab_connect_server_selected, self, 0);
	baobab_connect_server_show (connect_server);
	_g_object_unref0 (connect_server);
}


static gpointer _baobab_location_ref0 (gpointer self) {
	return self ? baobab_location_ref (self) : NULL;
}


static void baobab_window_set_active_location (BaobabWindow* self, BaobabLocation* location) {
	gulong _tmp0_;
	BaobabLocation* _tmp5_;
	BaobabLocation* _tmp6_;
	BaobabLocationList* _tmp7_;
	BaobabLocation* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (location != NULL);
	_tmp0_ = self->priv->scan_completed_handler;
	if (_tmp0_ > ((gulong) 0)) {
		BaobabLocation* _tmp1_;
		BaobabScanner* _tmp2_;
		BaobabScanner* _tmp3_;
		gulong _tmp4_;
		_tmp1_ = self->priv->active_location;
		_tmp2_ = baobab_location_get_scanner (_tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = self->priv->scan_completed_handler;
		g_signal_handler_disconnect ((GObject*) _tmp3_, _tmp4_);
		self->priv->scan_completed_handler = (gulong) 0;
	}
	_tmp5_ = location;
	_tmp6_ = _baobab_location_ref0 (_tmp5_);
	_baobab_location_unref0 (self->priv->active_location);
	self->priv->active_location = _tmp6_;
	_tmp7_ = self->priv->location_list;
	_tmp8_ = location;
	baobab_location_list_add_location (_tmp7_, _tmp8_);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		BaobabWindow * self;
		self = _data2_->self;
		_baobab_location_unref0 (_data2_->location);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static void ___lambda8_ (Block2Data* _data2_, GObject* location_, GAsyncResult* res) {
	BaobabWindow * self;
	GError * _inner_error_ = NULL;
	self = _data2_->self;
	g_return_if_fail (res != NULL);
	{
		BaobabLocation* _tmp0_;
		GAsyncResult* _tmp1_;
		_tmp0_ = _data2_->location;
		_tmp1_ = res;
		baobab_location_mount_volume_finish (_tmp0_, _tmp1_, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch10_g_error;
		}
		baobab_window_scan_active_location (self, FALSE);
	}
	goto __finally10;
	__catch10_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp2_ = NULL;
		GError* _tmp3_;
		const gchar* _tmp4_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = _ ("Could not analyze volume.");
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		baobab_window_message (self, _tmp2_, _tmp4_, GTK_MESSAGE_ERROR);
		_g_error_free0 (e);
	}
	__finally10:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ____lambda8__gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
	___lambda8_ (self, source_object, res);
	block2_data_unref (self);
}


static void baobab_window_on_scan_location_activate (BaobabWindow* self, BaobabLocation* location) {
	Block2Data* _data2_;
	BaobabLocation* _tmp0_;
	BaobabLocation* _tmp1_;
	BaobabLocation* _tmp2_;
	BaobabLocation* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (location != NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	_tmp0_ = location;
	_tmp1_ = _baobab_location_ref0 (_tmp0_);
	_baobab_location_unref0 (_data2_->location);
	_data2_->location = _tmp1_;
	_tmp2_ = _data2_->location;
	baobab_window_set_active_location (self, _tmp2_);
	_tmp3_ = _data2_->location;
	_tmp4_ = baobab_location_get_is_volume (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_) {
		BaobabLocation* _tmp6_;
		_tmp6_ = _data2_->location;
		baobab_location_mount_volume (_tmp6_, ____lambda8__gasync_ready_callback, block2_data_ref (_data2_));
	} else {
		baobab_window_scan_active_location (self, FALSE);
	}
	block2_data_unref (_data2_);
	_data2_ = NULL;
}


static void baobab_window_on_reload_activate (BaobabWindow* self) {
	BaobabLocation* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->active_location;
	if (_tmp0_ != NULL) {
		BaobabLocation* _tmp1_;
		BaobabScanner* _tmp2_;
		BaobabScanner* _tmp3_;
		_tmp1_ = self->priv->active_location;
		_tmp2_ = baobab_location_get_scanner (_tmp1_);
		_tmp3_ = _tmp2_;
		if (_tmp3_ != NULL) {
			BaobabLocation* _tmp4_;
			BaobabScanner* _tmp5_;
			BaobabScanner* _tmp6_;
			_tmp4_ = self->priv->active_location;
			_tmp5_ = baobab_location_get_scanner (_tmp4_);
			_tmp6_ = _tmp5_;
			baobab_scanner_cancel (_tmp6_);
		}
		baobab_window_scan_active_location (self, TRUE);
	}
}


static void baobab_window_on_show_allocated (BaobabWindow* self) {
	g_return_if_fail (self != NULL);
}


static void baobab_window_on_expand_all (BaobabWindow* self) {
	GtkTreeView* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->treeview;
	gtk_tree_view_expand_all (_tmp0_);
}


static void baobab_window_on_collapse_all (BaobabWindow* self) {
	GtkTreeView* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->treeview;
	gtk_tree_view_collapse_all (_tmp0_);
}


static void baobab_window_on_help_activate (BaobabWindow* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		GdkScreen* _tmp0_ = NULL;
		guint32 _tmp1_ = 0U;
		_tmp0_ = gtk_window_get_screen ((GtkWindow*) self);
		_tmp1_ = gtk_get_current_event_time ();
		gtk_show_uri (_tmp0_, "help:baobab", _tmp1_, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch11_g_error;
		}
	}
	goto __finally11;
	__catch11_g_error:
	{
		GError* e = NULL;
		GError* _tmp2_;
		const gchar* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		g_warning ("baobab-window.vala:295: Failed to show help: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally11:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void baobab_window_on_about_activate (BaobabWindow* self) {
	static const gchar* authors[] = {"Ryan Lortie <desrt@desrt.ca>", "Fabio Marzocca <thesaltydog@gmail.com>", "Paolo Borelli <pborelli@gnome.com>", "Stefano Facchini <stefano.facchini@gmail.com>", "Benot Dejean <benoit@placenet.org>", "Igalia (rings-chart and treemap widget) <www.igalia.com>", NULL};
	static const char copyright[] = "Copyright \xc2\xa9 2005-2011 Fabio Marzocca, Paolo Borelli, Benot Dej" \
"ean, Igalia\n" "Copyright \xc2\xa9 2011-2012 Ryan Lortie, Paolo Borelli, Stefano Facch" \
"ini\n";
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = _ ("Baobab");
	_tmp1_ = _ ("A graphical tool to analyze disk usage.");
	_tmp2_ = _ ("translator-credits");
	gtk_show_about_dialog ((GtkWindow*) self, "program-name", _tmp0_, "logo-icon-name", "baobab", "version", VERSION, "comments", _tmp1_, "copyright", copyright, "license-type", GTK_LICENSE_GPL_2_0, "wrap-license", FALSE, "authors", authors, "translator-credits", _tmp2_, NULL, NULL);
}


static void baobab_window_on_chart_item_activated (BaobabWindow* self, BaobabChart* chart, GtkTreeIter* iter) {
	BaobabLocation* _tmp0_;
	BaobabScanner* _tmp1_;
	BaobabScanner* _tmp2_;
	GtkTreeIter _tmp3_;
	GtkTreePath* _tmp4_ = NULL;
	GtkTreePath* path;
	GtkTreeView* _tmp5_;
	GtkTreePath* _tmp6_;
	gboolean _tmp7_ = FALSE;
	GtkTreeView* _tmp10_;
	GtkTreePath* _tmp11_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (chart != NULL);
	g_return_if_fail (iter != NULL);
	_tmp0_ = self->priv->active_location;
	_tmp1_ = baobab_location_get_scanner (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = *iter;
	_tmp4_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp2_, &_tmp3_);
	path = _tmp4_;
	_tmp5_ = self->priv->treeview;
	_tmp6_ = path;
	_tmp7_ = gtk_tree_view_row_expanded (_tmp5_, _tmp6_);
	if (!_tmp7_) {
		GtkTreeView* _tmp8_;
		GtkTreePath* _tmp9_;
		_tmp8_ = self->priv->treeview;
		_tmp9_ = path;
		gtk_tree_view_expand_to_path (_tmp8_, _tmp9_);
	}
	_tmp10_ = self->priv->treeview;
	_tmp11_ = path;
	gtk_tree_view_set_cursor (_tmp10_, _tmp11_, NULL, FALSE);
	_gtk_tree_path_free0 (path);
}


static void baobab_window_on_drag_data_received (BaobabWindow* self, GtkWidget* widget, GdkDragContext* context, gint x, gint y, GtkSelectionData* selection_data, guint target_type, guint time) {
	GFile* dir;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GtkSelectionData* _tmp2_;
	gboolean _tmp5_;
	gboolean _tmp7_;
	GFile* _tmp19_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (selection_data != NULL);
	dir = NULL;
	_tmp2_ = selection_data;
	if (_tmp2_ != NULL) {
		GtkSelectionData* _tmp3_;
		gint _tmp4_ = 0;
		_tmp3_ = selection_data;
		_tmp4_ = gtk_selection_data_get_length (_tmp3_);
		_tmp1_ = _tmp4_ >= 0;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp5_ = _tmp1_;
	if (_tmp5_) {
		guint _tmp6_;
		_tmp6_ = target_type;
		_tmp0_ = _tmp6_ == ((guint) BAOBAB_WINDOW_DND_TARGETS_URI_LIST);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp7_ = _tmp0_;
	if (_tmp7_) {
		GtkSelectionData* _tmp8_;
		guchar* _tmp9_ = NULL;
		gchar** _tmp10_;
		gchar** _tmp11_ = NULL;
		gchar** uris;
		gint uris_length1;
		gint _uris_size_;
		gboolean _tmp12_ = FALSE;
		gchar** _tmp13_;
		gint _tmp13__length1;
		gboolean _tmp15_;
		_tmp8_ = selection_data;
		_tmp9_ = gtk_selection_data_get_data (_tmp8_);
		_tmp11_ = _tmp10_ = g_uri_list_extract_uris ((const gchar*) _tmp9_);
		uris = _tmp11_;
		uris_length1 = _vala_array_length (_tmp10_);
		_uris_size_ = uris_length1;
		_tmp13_ = uris;
		_tmp13__length1 = uris_length1;
		if (_tmp13_ != NULL) {
			gchar** _tmp14_;
			gint _tmp14__length1;
			_tmp14_ = uris;
			_tmp14__length1 = uris_length1;
			_tmp12_ = _tmp14__length1 == 1;
		} else {
			_tmp12_ = FALSE;
		}
		_tmp15_ = _tmp12_;
		if (_tmp15_) {
			gchar** _tmp16_;
			gint _tmp16__length1;
			const gchar* _tmp17_;
			GFile* _tmp18_ = NULL;
			_tmp16_ = uris;
			_tmp16__length1 = uris_length1;
			_tmp17_ = _tmp16_[0];
			_tmp18_ = g_file_new_for_uri (_tmp17_);
			_g_object_unref0 (dir);
			dir = _tmp18_;
		}
		uris = (_vala_array_free (uris, uris_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp19_ = dir;
	if (_tmp19_ != NULL) {
		GdkDragContext* _tmp20_;
		guint _tmp21_;
		GFile* _tmp22_;
		_tmp20_ = context;
		_tmp21_ = time;
		gtk_drag_finish (_tmp20_, TRUE, FALSE, (guint32) _tmp21_);
		_tmp22_ = dir;
		baobab_window_scan_directory (self, _tmp22_);
	} else {
		GdkDragContext* _tmp23_;
		guint _tmp24_;
		_tmp23_ = context;
		_tmp24_ = time;
		gtk_drag_finish (_tmp23_, FALSE, FALSE, (guint32) _tmp24_);
	}
	_g_object_unref0 (dir);
}


static void baobab_window_enable_drop (BaobabWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_drag_dest_set ((GtkWidget*) self, (GTK_DEST_DEFAULT_DROP | GTK_DEST_DEFAULT_MOTION) | GTK_DEST_DEFAULT_HIGHLIGHT, BAOBAB_WINDOW_dnd_target_list, G_N_ELEMENTS (BAOBAB_WINDOW_dnd_target_list), GDK_ACTION_COPY);
}


static void baobab_window_disable_drop (BaobabWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_drag_dest_unset ((GtkWidget*) self);
}


static gboolean baobab_window_show_treeview_popup (BaobabWindow* self, GtkMenu* popup, GdkEventButton* event) {
	gboolean result = FALSE;
	GdkEventButton* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (popup != NULL, FALSE);
	_tmp0_ = event;
	if (_tmp0_ != NULL) {
		GtkMenu* _tmp1_;
		GdkEventButton* _tmp2_;
		guint _tmp3_;
		GdkEventButton* _tmp4_;
		guint32 _tmp5_;
		_tmp1_ = popup;
		_tmp2_ = event;
		_tmp3_ = (*_tmp2_).button;
		_tmp4_ = event;
		_tmp5_ = (*_tmp4_).time;
		gtk_menu_popup (_tmp1_, NULL, NULL, NULL, NULL, _tmp3_, _tmp5_);
	} else {
		GtkMenu* _tmp6_;
		guint32 _tmp7_ = 0U;
		GtkMenu* _tmp8_;
		_tmp6_ = popup;
		_tmp7_ = gtk_get_current_event_time ();
		gtk_menu_popup (_tmp6_, NULL, NULL, NULL, NULL, (guint) 0, _tmp7_);
		_tmp8_ = popup;
		gtk_menu_shell_select_first ((GtkMenuShell*) _tmp8_, FALSE);
	}
	result = TRUE;
	return result;
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		BaobabWindow * self;
		self = _data3_->self;
		_g_object_unref0 (_data3_->selection);
		_g_object_unref0 (_data3_->popup);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static gboolean __lambda9_ (Block3Data* _data3_, GdkEventButton* event) {
	BaobabWindow * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	self = _data3_->self;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = gdk_event_triggers_context_menu ((GdkEvent*) (event));
	if (_tmp0_) {
		GdkEventButton _tmp1_;
		gboolean _tmp2_ = FALSE;
		_tmp1_ = *event;
		_tmp2_ = baobab_window_show_treeview_popup (self, _data3_->popup, &_tmp1_);
		result = _tmp2_;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda9__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda9_ (self, event);
	return result;
}


static gboolean __lambda10_ (Block3Data* _data3_) {
	BaobabWindow * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	self = _data3_->self;
	_tmp0_ = baobab_window_show_treeview_popup (self, _data3_->popup, NULL);
	result = _tmp0_;
	return result;
}


static gboolean ___lambda10__gtk_widget_popup_menu (GtkWidget* _sender, gpointer self) {
	gboolean result;
	result = __lambda10_ (self);
	return result;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static void __lambda11_ (BaobabWindow* self) {
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeSelection* _tmp2_;
	GtkTreeSelection* selection;
	GtkTreeIter iter = {0};
	GtkTreeSelection* _tmp3_;
	GtkTreeIter _tmp4_ = {0};
	gboolean _tmp5_ = FALSE;
	GError * _inner_error_ = NULL;
	_tmp0_ = self->priv->treeview;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	selection = _tmp2_;
	_tmp3_ = selection;
	_tmp5_ = gtk_tree_selection_get_selected (_tmp3_, NULL, &_tmp4_);
	iter = _tmp4_;
	if (_tmp5_) {
		gchar* parse_name = NULL;
		BaobabLocation* _tmp6_;
		BaobabScanner* _tmp7_;
		BaobabScanner* _tmp8_;
		GtkTreeIter _tmp9_;
		const gchar* _tmp10_;
		GFile* _tmp11_ = NULL;
		GFile* file;
		_tmp6_ = self->priv->active_location;
		_tmp7_ = baobab_location_get_scanner (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = iter;
		gtk_tree_model_get ((GtkTreeModel*) _tmp8_, &_tmp9_, BAOBAB_SCANNER_COLUMNS_PARSE_NAME, &parse_name, -1);
		_tmp10_ = parse_name;
		_tmp11_ = g_file_parse_name (_tmp10_);
		file = _tmp11_;
		{
			GFile* _tmp12_;
			GFileInfo* _tmp13_ = NULL;
			GFileInfo* info;
			GFileInfo* _tmp14_;
			const gchar* _tmp15_ = NULL;
			gchar* _tmp16_;
			gchar* content;
			const gchar* _tmp17_;
			GAppInfo* _tmp18_ = NULL;
			GAppInfo* appinfo;
			GList* files;
			GFile* _tmp19_;
			GFile* _tmp20_;
			GAppInfo* _tmp21_;
			GList* _tmp22_;
			_tmp12_ = file;
			_tmp13_ = g_file_query_info (_tmp12_, G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE, 0, NULL, &_inner_error_);
			info = _tmp13_;
			if (_inner_error_ != NULL) {
				goto __catch12_g_error;
			}
			_tmp14_ = info;
			_tmp15_ = g_file_info_get_content_type (_tmp14_);
			_tmp16_ = g_strdup (_tmp15_);
			content = _tmp16_;
			_tmp17_ = content;
			_tmp18_ = g_app_info_get_default_for_type (_tmp17_, TRUE);
			appinfo = _tmp18_;
			files = NULL;
			_tmp19_ = file;
			_tmp20_ = _g_object_ref0 (_tmp19_);
			files = g_list_append (files, _tmp20_);
			_tmp21_ = appinfo;
			_tmp22_ = files;
			g_app_info_launch (_tmp21_, _tmp22_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				__g_list_free__g_object_unref0_0 (files);
				_g_object_unref0 (appinfo);
				_g_free0 (content);
				_g_object_unref0 (info);
				goto __catch12_g_error;
			}
			__g_list_free__g_object_unref0_0 (files);
			_g_object_unref0 (appinfo);
			_g_free0 (content);
			_g_object_unref0 (info);
		}
		goto __finally12;
		__catch12_g_error:
		{
			GError* e = NULL;
			GError* _tmp23_;
			const gchar* _tmp24_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp23_ = e;
			_tmp24_ = _tmp23_->message;
			g_warning ("baobab-window.vala:410: Failed open file with application: %s", _tmp24_);
			_g_error_free0 (e);
		}
		__finally12:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (file);
			_g_free0 (parse_name);
			_g_object_unref0 (selection);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_object_unref0 (file);
		_g_free0 (parse_name);
	}
	_g_object_unref0 (selection);
}


static void ___lambda11__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda11_ (self);
}


static void __lambda12_ (BaobabWindow* self) {
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeSelection* _tmp2_;
	GtkTreeSelection* selection;
	GtkTreeIter iter = {0};
	GtkTreeSelection* _tmp3_;
	GtkTreeIter _tmp4_ = {0};
	gboolean _tmp5_ = FALSE;
	_tmp0_ = self->priv->treeview;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	selection = _tmp2_;
	_tmp3_ = selection;
	_tmp5_ = gtk_tree_selection_get_selected (_tmp3_, NULL, &_tmp4_);
	iter = _tmp4_;
	if (_tmp5_) {
		gchar* parse_name = NULL;
		BaobabLocation* _tmp6_;
		BaobabScanner* _tmp7_;
		BaobabScanner* _tmp8_;
		GtkTreeIter _tmp9_;
		GtkClipboard* _tmp10_ = NULL;
		GtkClipboard* _tmp11_;
		GtkClipboard* clipboard;
		GtkClipboard* _tmp12_;
		const gchar* _tmp13_;
		GtkClipboard* _tmp14_;
		_tmp6_ = self->priv->active_location;
		_tmp7_ = baobab_location_get_scanner (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = iter;
		gtk_tree_model_get ((GtkTreeModel*) _tmp8_, &_tmp9_, BAOBAB_SCANNER_COLUMNS_PARSE_NAME, &parse_name, -1);
		_tmp10_ = gtk_clipboard_get (GDK_SELECTION_CLIPBOARD);
		_tmp11_ = _g_object_ref0 (_tmp10_);
		clipboard = _tmp11_;
		_tmp12_ = clipboard;
		_tmp13_ = parse_name;
		gtk_clipboard_set_text (_tmp12_, _tmp13_, -1);
		_tmp14_ = clipboard;
		gtk_clipboard_store (_tmp14_);
		_g_object_unref0 (clipboard);
		_g_free0 (parse_name);
	}
	_g_object_unref0 (selection);
}


static void ___lambda12__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda12_ (self);
}


static void __lambda13_ (BaobabWindow* self) {
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeSelection* _tmp2_;
	GtkTreeSelection* selection;
	GtkTreeIter iter = {0};
	GtkTreeSelection* _tmp3_;
	GtkTreeIter _tmp4_ = {0};
	gboolean _tmp5_ = FALSE;
	GError * _inner_error_ = NULL;
	_tmp0_ = self->priv->treeview;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	selection = _tmp2_;
	_tmp3_ = selection;
	_tmp5_ = gtk_tree_selection_get_selected (_tmp3_, NULL, &_tmp4_);
	iter = _tmp4_;
	if (_tmp5_) {
		gchar* parse_name = NULL;
		BaobabLocation* _tmp6_;
		BaobabScanner* _tmp7_;
		BaobabScanner* _tmp8_;
		GtkTreeIter _tmp9_;
		const gchar* _tmp10_;
		GFile* _tmp11_ = NULL;
		GFile* file;
		_tmp6_ = self->priv->active_location;
		_tmp7_ = baobab_location_get_scanner (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = iter;
		gtk_tree_model_get ((GtkTreeModel*) _tmp8_, &_tmp9_, BAOBAB_SCANNER_COLUMNS_PARSE_NAME, &parse_name, -1);
		_tmp10_ = parse_name;
		_tmp11_ = g_file_parse_name (_tmp10_);
		file = _tmp11_;
		{
			GFile* _tmp12_;
			BaobabLocation* _tmp13_;
			BaobabScanner* _tmp14_;
			BaobabScanner* _tmp15_;
			_tmp12_ = file;
			g_file_trash (_tmp12_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch13_g_error;
			}
			_tmp13_ = self->priv->active_location;
			_tmp14_ = baobab_location_get_scanner (_tmp13_);
			_tmp15_ = _tmp14_;
			gtk_tree_store_remove ((GtkTreeStore*) _tmp15_, &iter);
		}
		goto __finally13;
		__catch13_g_error:
		{
			GError* e = NULL;
			GError* _tmp16_;
			const gchar* _tmp17_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp16_ = e;
			_tmp17_ = _tmp16_->message;
			g_warning ("baobab-window.vala:438: Failed to move file to the trash: %s", _tmp17_);
			_g_error_free0 (e);
		}
		__finally13:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (file);
			_g_free0 (parse_name);
			_g_object_unref0 (selection);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_object_unref0 (file);
		_g_free0 (parse_name);
	}
	_g_object_unref0 (selection);
}


static void ___lambda13__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda13_ (self);
}


static void __lambda14_ (Block3Data* _data3_) {
	BaobabWindow * self;
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	self = _data3_->self;
	_tmp1_ = gtk_tree_selection_get_selected (_data3_->selection, NULL, &_tmp0_);
	iter = _tmp0_;
	if (_tmp1_) {
		BaobabLocation* _tmp2_;
		BaobabScanner* _tmp3_;
		BaobabScanner* _tmp4_;
		GtkTreeIter _tmp5_;
		GtkTreePath* _tmp6_ = NULL;
		GtkTreePath* path;
		BaobabChart* _tmp7_;
		GtkTreePath* _tmp8_;
		BaobabChart* _tmp9_;
		GtkTreePath* _tmp10_;
		_tmp2_ = self->priv->active_location;
		_tmp3_ = baobab_location_get_scanner (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = iter;
		_tmp6_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp4_, &_tmp5_);
		path = _tmp6_;
		_tmp7_ = self->priv->rings_chart;
		_tmp8_ = path;
		baobab_chart_set_root (_tmp7_, _tmp8_);
		_tmp9_ = self->priv->treemap_chart;
		_tmp10_ = path;
		baobab_chart_set_root (_tmp9_, _tmp10_);
		_gtk_tree_path_free0 (path);
	}
}


static void ___lambda14__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	__lambda14_ (self);
}


static void baobab_window_setup_treeview (BaobabWindow* self, GtkBuilder* builder) {
	Block3Data* _data3_;
	GtkBuilder* _tmp0_;
	GObject* _tmp1_ = NULL;
	GtkMenu* _tmp2_;
	GtkBuilder* _tmp3_;
	GObject* _tmp4_ = NULL;
	GtkMenuItem* _tmp5_;
	GtkMenuItem* open_item;
	GtkBuilder* _tmp6_;
	GObject* _tmp7_ = NULL;
	GtkMenuItem* _tmp8_;
	GtkMenuItem* copy_item;
	GtkBuilder* _tmp9_;
	GObject* _tmp10_ = NULL;
	GtkMenuItem* _tmp11_;
	GtkMenuItem* trash_item;
	GtkTreeView* _tmp12_;
	GtkTreeView* _tmp13_;
	GtkTreeView* _tmp14_;
	GtkTreeSelection* _tmp15_ = NULL;
	GtkTreeSelection* _tmp16_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (builder != NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->self = g_object_ref (self);
	_tmp0_ = builder;
	_tmp1_ = gtk_builder_get_object (_tmp0_, "treeview-popup-menu");
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, GTK_TYPE_MENU) ? ((GtkMenu*) _tmp1_) : NULL);
	_data3_->popup = _tmp2_;
	_tmp3_ = builder;
	_tmp4_ = gtk_builder_get_object (_tmp3_, "treeview-popup-open");
	_tmp5_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, GTK_TYPE_MENU_ITEM) ? ((GtkMenuItem*) _tmp4_) : NULL);
	open_item = _tmp5_;
	_tmp6_ = builder;
	_tmp7_ = gtk_builder_get_object (_tmp6_, "treeview-popup-copy");
	_tmp8_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp7_, GTK_TYPE_MENU_ITEM) ? ((GtkMenuItem*) _tmp7_) : NULL);
	copy_item = _tmp8_;
	_tmp9_ = builder;
	_tmp10_ = gtk_builder_get_object (_tmp9_, "treeview-popup-trash");
	_tmp11_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp10_, GTK_TYPE_MENU_ITEM) ? ((GtkMenuItem*) _tmp10_) : NULL);
	trash_item = _tmp11_;
	_tmp12_ = self->priv->treeview;
	g_signal_connect_data ((GtkWidget*) _tmp12_, "button-press-event", (GCallback) ___lambda9__gtk_widget_button_press_event, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	_tmp13_ = self->priv->treeview;
	g_signal_connect_data ((GtkWidget*) _tmp13_, "popup-menu", (GCallback) ___lambda10__gtk_widget_popup_menu, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	g_signal_connect_object (open_item, "activate", (GCallback) ___lambda11__gtk_menu_item_activate, self, 0);
	g_signal_connect_object (copy_item, "activate", (GCallback) ___lambda12__gtk_menu_item_activate, self, 0);
	g_signal_connect_object (trash_item, "activate", (GCallback) ___lambda13__gtk_menu_item_activate, self, 0);
	_tmp14_ = self->priv->treeview;
	_tmp15_ = gtk_tree_view_get_selection (_tmp14_);
	_tmp16_ = _g_object_ref0 (_tmp15_);
	_data3_->selection = _tmp16_;
	g_signal_connect_data (_data3_->selection, "changed", (GCallback) ___lambda14__gtk_tree_selection_changed, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	_g_object_unref0 (trash_item);
	_g_object_unref0 (copy_item);
	_g_object_unref0 (open_item);
	block3_data_unref (_data3_);
	_data3_ = NULL;
}


static void baobab_window_message (BaobabWindow* self, const gchar* primary_msg, const gchar* secondary_msg, GtkMessageType type) {
	GtkInfoBar* _tmp0_;
	GtkMessageType _tmp1_;
	GtkLabel* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	GtkLabel* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	GtkInfoBar* _tmp12_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (primary_msg != NULL);
	g_return_if_fail (secondary_msg != NULL);
	_tmp0_ = self->priv->infobar;
	_tmp1_ = type;
	gtk_info_bar_set_message_type (_tmp0_, _tmp1_);
	_tmp2_ = self->priv->infobar_primary;
	_tmp3_ = primary_msg;
	_tmp4_ = _ (_tmp3_);
	_tmp5_ = g_strdup_printf ("<b>%s</b>", _tmp4_);
	_tmp6_ = _tmp5_;
	gtk_label_set_label (_tmp2_, _tmp6_);
	_g_free0 (_tmp6_);
	_tmp7_ = self->priv->infobar_secondary;
	_tmp8_ = secondary_msg;
	_tmp9_ = _ (_tmp8_);
	_tmp10_ = g_strdup_printf ("<small>%s</small>", _tmp9_);
	_tmp11_ = _tmp10_;
	gtk_label_set_label (_tmp7_, _tmp11_);
	_g_free0 (_tmp11_);
	_tmp12_ = self->priv->infobar;
	gtk_widget_show ((GtkWidget*) _tmp12_);
}


static void baobab_window_clear_message (BaobabWindow* self) {
	GtkInfoBar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->infobar;
	gtk_widget_hide ((GtkWidget*) _tmp0_);
}


static void baobab_window_set_busy (BaobabWindow* self, gboolean busy) {
	GdkCursor* cursor;
	gboolean _tmp0_;
	GdkWindow* _tmp17_ = NULL;
	GdkWindow* _tmp18_;
	GdkWindow* window;
	GdkWindow* _tmp19_;
	g_return_if_fail (self != NULL);
	cursor = NULL;
	_tmp0_ = busy;
	if (_tmp0_) {
		GdkCursor* _tmp1_;
		GdkCursor* _tmp2_;
		BaobabChart* _tmp3_;
		BaobabChart* _tmp4_;
		GAction* _tmp5_ = NULL;
		GdStack* _tmp6_;
		GtkSpinner* _tmp7_;
		GtkSpinner* _tmp8_;
		_tmp1_ = baobab_window_busy_cursor;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_g_object_unref0 (cursor);
		cursor = _tmp2_;
		baobab_window_disable_drop (self);
		_tmp3_ = self->priv->rings_chart;
		baobab_chart_freeze_updates (_tmp3_);
		_tmp4_ = self->priv->treemap_chart;
		baobab_chart_freeze_updates (_tmp4_);
		_tmp5_ = g_action_map_lookup_action ((GActionMap*) self, "active-chart");
		g_simple_action_set_enabled (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp5_) : NULL, FALSE);
		_tmp6_ = self->priv->chart_stack;
		_tmp7_ = self->priv->spinner;
		gd_stack_set_visible_child (_tmp6_, (GtkWidget*) _tmp7_);
		_tmp8_ = self->priv->spinner;
		gtk_spinner_start (_tmp8_);
	} else {
		BaobabChart* _tmp9_;
		BaobabChart* _tmp10_;
		GAction* _tmp11_ = NULL;
		GtkSpinner* _tmp12_;
		GAction* _tmp13_ = NULL;
		GSettings* _tmp14_;
		GVariant* _tmp15_ = NULL;
		GVariant* _tmp16_;
		baobab_window_enable_drop (self);
		_tmp9_ = self->priv->rings_chart;
		baobab_chart_thaw_updates (_tmp9_);
		_tmp10_ = self->priv->treemap_chart;
		baobab_chart_thaw_updates (_tmp10_);
		_tmp11_ = g_action_map_lookup_action ((GActionMap*) self, "active-chart");
		g_simple_action_set_enabled (G_TYPE_CHECK_INSTANCE_TYPE (_tmp11_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp11_) : NULL, TRUE);
		_tmp12_ = self->priv->spinner;
		gtk_spinner_stop (_tmp12_);
		_tmp13_ = g_action_map_lookup_action ((GActionMap*) self, "active-chart");
		_tmp14_ = self->priv->ui_settings;
		_tmp15_ = g_settings_get_value (_tmp14_, "active-chart");
		_tmp16_ = _tmp15_;
		g_action_change_state (_tmp13_, _tmp16_);
		_g_variant_unref0 (_tmp16_);
	}
	_tmp17_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp18_ = _g_object_ref0 (_tmp17_);
	window = _tmp18_;
	_tmp19_ = window;
	if (_tmp19_ != NULL) {
		GdkWindow* _tmp20_;
		GdkCursor* _tmp21_;
		_tmp20_ = window;
		_tmp21_ = cursor;
		gdk_window_set_cursor (_tmp20_, _tmp21_);
	}
	{
		BaobabWindowActionState* action_state_collection = NULL;
		gint action_state_collection_length1 = 0;
		gint _action_state_collection_size_ = 0;
		gint action_state_it = 0;
		action_state_collection = BAOBAB_WINDOW_actions_while_scanning;
		action_state_collection_length1 = G_N_ELEMENTS (BAOBAB_WINDOW_actions_while_scanning);
		for (action_state_it = 0; action_state_it < G_N_ELEMENTS (BAOBAB_WINDOW_actions_while_scanning); action_state_it = action_state_it + 1) {
			BaobabWindowActionState _tmp22_ = {0};
			BaobabWindowActionState action_state = {0};
			baobab_window_action_state_copy (&action_state_collection[action_state_it], &_tmp22_);
			action_state = _tmp22_;
			{
				BaobabWindowActionState _tmp23_;
				const gchar* _tmp24_;
				GAction* _tmp25_ = NULL;
				GSimpleAction* _tmp26_;
				GSimpleAction* action;
				GSimpleAction* _tmp27_;
				gboolean _tmp28_;
				BaobabWindowActionState _tmp29_;
				gboolean _tmp30_;
				_tmp23_ = action_state;
				_tmp24_ = _tmp23_.name;
				_tmp25_ = g_action_map_lookup_action ((GActionMap*) self, _tmp24_);
				_tmp26_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp25_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp25_) : NULL);
				action = _tmp26_;
				_tmp27_ = action;
				_tmp28_ = busy;
				_tmp29_ = action_state;
				_tmp30_ = _tmp29_.enable;
				g_simple_action_set_enabled (_tmp27_, _tmp28_ == _tmp30_);
				_g_object_unref0 (action);
				baobab_window_action_state_destroy (&action_state);
			}
		}
	}
	_g_object_unref0 (window);
	_g_object_unref0 (cursor);
}


static void baobab_window_set_ui_state (BaobabWindow* self, GtkWidget* child, gboolean busy) {
	GdHeaderBar* _tmp0_;
	GtkWidget* _tmp1_;
	GtkWidget* _tmp2_;
	GdHeaderBar* _tmp3_;
	GtkWidget* _tmp4_;
	GtkWidget* _tmp5_;
	gboolean _tmp6_;
	GtkWidget* _tmp7_;
	GtkWidget* _tmp8_;
	GdStack* _tmp21_;
	GtkWidget* _tmp22_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	_tmp0_ = self->priv->header_bar;
	_tmp1_ = child;
	_tmp2_ = self->priv->home_page;
	gtk_widget_set_visible ((GtkWidget*) _tmp0_, _tmp1_ == _tmp2_);
	_tmp3_ = self->priv->result_header_bar;
	_tmp4_ = child;
	_tmp5_ = self->priv->result_page;
	gtk_widget_set_visible ((GtkWidget*) _tmp3_, _tmp4_ == _tmp5_);
	_tmp6_ = busy;
	baobab_window_set_busy (self, _tmp6_);
	_tmp7_ = child;
	_tmp8_ = self->priv->home_page;
	if (_tmp7_ == _tmp8_) {
		GAction* _tmp9_ = NULL;
		GSimpleAction* _tmp10_;
		GSimpleAction* action;
		GSimpleAction* _tmp11_;
		GdStack* _tmp12_;
		_tmp9_ = g_action_map_lookup_action ((GActionMap*) self, "reload");
		_tmp10_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp9_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp9_) : NULL);
		action = _tmp10_;
		_tmp11_ = action;
		g_simple_action_set_enabled (_tmp11_, FALSE);
		_tmp12_ = self->priv->main_stack;
		gd_stack_set_transition_type (_tmp12_, (gint) GD_STACK_TRANSITION_TYPE_SLIDE_RIGHT);
		_g_object_unref0 (action);
	} else {
		GAction* _tmp13_ = NULL;
		GSimpleAction* _tmp14_;
		GSimpleAction* action;
		GSimpleAction* _tmp15_;
		GdHeaderBar* _tmp16_;
		BaobabLocation* _tmp17_;
		const gchar* _tmp18_;
		const gchar* _tmp19_;
		GdStack* _tmp20_;
		_tmp13_ = g_action_map_lookup_action ((GActionMap*) self, "reload");
		_tmp14_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp13_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp13_) : NULL);
		action = _tmp14_;
		_tmp15_ = action;
		g_simple_action_set_enabled (_tmp15_, TRUE);
		_tmp16_ = self->priv->result_header_bar;
		_tmp17_ = self->priv->active_location;
		_tmp18_ = baobab_location_get_name (_tmp17_);
		_tmp19_ = _tmp18_;
		gd_header_bar_set_title (_tmp16_, _tmp19_);
		_tmp20_ = self->priv->main_stack;
		gd_stack_set_transition_type (_tmp20_, (gint) GD_STACK_TRANSITION_TYPE_SLIDE_LEFT);
		_g_object_unref0 (action);
	}
	_tmp21_ = self->priv->main_stack;
	_tmp22_ = child;
	gd_stack_set_visible_child (_tmp21_, _tmp22_);
}


static void _baobab_window_first_row_has_child_gtk_tree_model_row_has_child_toggled (GtkTreeModel* _sender, GtkTreePath* path, GtkTreeIter* iter, gpointer self) {
	baobab_window_first_row_has_child (self, _sender, path, iter);
}


static void baobab_window_first_row_has_child (BaobabWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter) {
	GtkTreeModel* _tmp0_;
	guint _tmp1_ = 0U;
	GtkTreeView* _tmp2_;
	GtkTreePath* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (model != NULL);
	g_return_if_fail (path != NULL);
	g_return_if_fail (iter != NULL);
	_tmp0_ = model;
	g_signal_parse_name ("row-has-child-toggled", GTK_TYPE_TREE_MODEL, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp0_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _baobab_window_first_row_has_child_gtk_tree_model_row_has_child_toggled, self);
	_tmp2_ = self->priv->treeview;
	_tmp3_ = path;
	gtk_tree_view_expand_row (_tmp2_, _tmp3_, FALSE);
}


static void baobab_window_expand_first_row (BaobabWindow* self) {
	GtkTreeIter first = {0};
	gboolean _tmp0_ = FALSE;
	GtkTreeView* _tmp1_;
	GtkTreeModel* _tmp2_;
	GtkTreeModel* _tmp3_;
	GtkTreeIter _tmp4_ = {0};
	gboolean _tmp5_ = FALSE;
	gboolean _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->priv->treeview;
	_tmp2_ = gtk_tree_view_get_model (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp5_ = gtk_tree_model_get_iter_first (_tmp3_, &_tmp4_);
	first = _tmp4_;
	if (_tmp5_) {
		GtkTreeView* _tmp6_;
		GtkTreeModel* _tmp7_;
		GtkTreeModel* _tmp8_;
		GtkTreeIter _tmp9_;
		gboolean _tmp10_ = FALSE;
		_tmp6_ = self->priv->treeview;
		_tmp7_ = gtk_tree_view_get_model (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = first;
		_tmp10_ = gtk_tree_model_iter_has_child (_tmp8_, &_tmp9_);
		_tmp0_ = _tmp10_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp11_ = _tmp0_;
	if (_tmp11_) {
		GtkTreeView* _tmp12_;
		GtkTreeView* _tmp13_;
		GtkTreeModel* _tmp14_;
		GtkTreeModel* _tmp15_;
		GtkTreeIter _tmp16_;
		GtkTreePath* _tmp17_ = NULL;
		GtkTreePath* _tmp18_;
		_tmp12_ = self->priv->treeview;
		_tmp13_ = self->priv->treeview;
		_tmp14_ = gtk_tree_view_get_model (_tmp13_);
		_tmp15_ = _tmp14_;
		_tmp16_ = first;
		_tmp17_ = gtk_tree_model_get_path (_tmp15_, &_tmp16_);
		_tmp18_ = _tmp17_;
		gtk_tree_view_expand_row (_tmp12_, _tmp18_, FALSE);
		_gtk_tree_path_free0 (_tmp18_);
	} else {
		GtkTreeView* _tmp19_;
		GtkTreeModel* _tmp20_;
		GtkTreeModel* _tmp21_;
		_tmp19_ = self->priv->treeview;
		_tmp20_ = gtk_tree_view_get_model (_tmp19_);
		_tmp21_ = _tmp20_;
		g_signal_connect_object (_tmp21_, "row-has-child-toggled", (GCallback) _baobab_window_first_row_has_child_gtk_tree_model_row_has_child_toggled, self, 0);
	}
}


static void baobab_window_set_model (BaobabWindow* self, GtkTreeModel* model) {
	GtkTreeView* _tmp0_;
	GtkTreeModel* _tmp1_;
	GtkTreeModel* _tmp2_;
	BaobabChart* _tmp3_;
	GtkTreeModel* _tmp4_;
	BaobabChart* _tmp5_;
	BaobabChart* _tmp6_;
	GtkTreeModel* _tmp7_;
	BaobabChart* _tmp8_;
	GtkTreeModel* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (model != NULL);
	_tmp0_ = self->priv->treeview;
	_tmp1_ = model;
	gtk_tree_view_set_model (_tmp0_, _tmp1_);
	baobab_window_expand_first_row (self);
	_tmp2_ = model;
	_tmp3_ = self->priv->rings_chart;
	g_object_bind_property_with_closures ((GObject*) _tmp2_, "max-depth", (GObject*) _tmp3_, "max-depth", G_BINDING_SYNC_CREATE, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)));
	_tmp4_ = model;
	_tmp5_ = self->priv->treemap_chart;
	g_object_bind_property_with_closures ((GObject*) _tmp4_, "max-depth", (GObject*) _tmp5_, "max-depth", G_BINDING_SYNC_CREATE, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)));
	_tmp6_ = self->priv->treemap_chart;
	_tmp7_ = model;
	baobab_chart_set_model_with_columns (_tmp6_, _tmp7_, (guint) BAOBAB_SCANNER_COLUMNS_DISPLAY_NAME, (guint) BAOBAB_SCANNER_COLUMNS_ALLOC_SIZE, (guint) BAOBAB_SCANNER_COLUMNS_PARSE_NAME, (guint) BAOBAB_SCANNER_COLUMNS_PERCENT, (guint) BAOBAB_SCANNER_COLUMNS_ELEMENTS, NULL);
	_tmp8_ = self->priv->rings_chart;
	_tmp9_ = model;
	baobab_chart_set_model_with_columns (_tmp8_, _tmp9_, (guint) BAOBAB_SCANNER_COLUMNS_DISPLAY_NAME, (guint) BAOBAB_SCANNER_COLUMNS_ALLOC_SIZE, (guint) BAOBAB_SCANNER_COLUMNS_PARSE_NAME, (guint) BAOBAB_SCANNER_COLUMNS_PERCENT, (guint) BAOBAB_SCANNER_COLUMNS_ELEMENTS, NULL);
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		BaobabWindow * self;
		self = _data4_->self;
		_g_object_unref0 (_data4_->scanner);
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}


static void __lambda5_ (Block4Data* _data4_) {
	BaobabWindow * self;
	GtkWidget* _tmp12_;
	GError * _inner_error_ = NULL;
	self = _data4_->self;
	{
		baobab_scanner_finish (_data4_->scanner, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (g_error_matches (_inner_error_, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
				goto __catch14_g_io_error_cancelled;
			}
			goto __catch14_g_error;
		}
	}
	goto __finally14;
	__catch14_g_io_error_cancelled:
	{
		GError* e = NULL;
		gulong _tmp0_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp0_ = self->priv->scan_completed_handler;
		if (_tmp0_ > ((gulong) 0)) {
			gulong _tmp1_;
			_tmp1_ = self->priv->scan_completed_handler;
			g_signal_handler_disconnect ((GObject*) _data4_->scanner, _tmp1_);
			self->priv->scan_completed_handler = (gulong) 0;
		}
		_g_error_free0 (e);
		return;
	}
	goto __finally14;
	__catch14_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp2_ = NULL;
		GFile* _tmp3_;
		GFile* _tmp4_;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* primary;
		const gchar* _tmp9_;
		GError* _tmp10_;
		const gchar* _tmp11_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = _ ("Could not scan folder \"%s\" or some of the folders it contains.");
		_tmp3_ = baobab_scanner_get_directory (_data4_->scanner);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_file_get_parse_name (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_strdup_printf (_tmp2_, _tmp6_);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		primary = _tmp8_;
		_tmp9_ = primary;
		_tmp10_ = e;
		_tmp11_ = _tmp10_->message;
		baobab_window_message (self, _tmp9_, _tmp11_, GTK_MESSAGE_WARNING);
		_g_free0 (primary);
		_g_error_free0 (e);
	}
	__finally14:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp12_ = self->priv->result_page;
	baobab_window_set_ui_state (self, _tmp12_, FALSE);
}


static void ___lambda5__baobab_scanner_completed (BaobabScanner* _sender, gpointer self) {
	__lambda5_ (self);
}


static void baobab_window_scan_active_location (BaobabWindow* self, gboolean force) {
	Block4Data* _data4_;
	BaobabLocation* _tmp0_;
	BaobabScanner* _tmp1_;
	BaobabScanner* _tmp2_;
	BaobabScanner* _tmp3_;
	gulong _tmp4_ = 0UL;
	GtkWidget* _tmp5_;
	gboolean _tmp6_;
	BaobabLocation* _tmp7_;
	BaobabScanner* _tmp8_;
	BaobabScanner* _tmp9_;
	g_return_if_fail (self != NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_tmp0_ = self->priv->active_location;
	_tmp1_ = baobab_location_get_scanner (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_data4_->scanner = _tmp3_;
	_tmp4_ = g_signal_connect_data (_data4_->scanner, "completed", (GCallback) ___lambda5__baobab_scanner_completed, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
	self->priv->scan_completed_handler = _tmp4_;
	baobab_window_clear_message (self);
	_tmp5_ = self->priv->result_page;
	baobab_window_set_ui_state (self, _tmp5_, TRUE);
	_tmp6_ = force;
	baobab_scanner_scan (_data4_->scanner, _tmp6_);
	_tmp7_ = self->priv->active_location;
	_tmp8_ = baobab_location_get_scanner (_tmp7_);
	_tmp9_ = _tmp8_;
	baobab_window_set_model (self, (GtkTreeModel*) _tmp9_);
	block4_data_unref (_data4_);
	_data4_ = NULL;
}


void baobab_window_scan_directory (BaobabWindow* self, GFile* directory) {
	GFile* _tmp0_;
	BaobabLocation* _tmp1_;
	BaobabLocation* location;
	BaobabLocation* _tmp2_;
	GFileInfo* _tmp3_;
	GFileInfo* _tmp4_;
	BaobabLocation* _tmp13_;
	GFileInfo* _tmp14_;
	GFileInfo* _tmp15_;
	GFileType _tmp16_ = 0;
	BaobabLocation* _tmp25_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (directory != NULL);
	_tmp0_ = directory;
	_tmp1_ = baobab_location_new_for_file (_tmp0_);
	location = _tmp1_;
	_tmp2_ = location;
	_tmp3_ = baobab_location_get_info (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == NULL) {
		const gchar* _tmp5_ = NULL;
		GFile* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gchar* primary;
		const gchar* _tmp11_;
		const gchar* _tmp12_ = NULL;
		_tmp5_ = _ ("\"%s\" is not a valid folder");
		_tmp6_ = directory;
		_tmp7_ = g_file_get_parse_name (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_strdup_printf (_tmp5_, _tmp8_);
		_tmp10_ = _tmp9_;
		_g_free0 (_tmp8_);
		primary = _tmp10_;
		_tmp11_ = primary;
		_tmp12_ = _ ("Could not analyze disk usage.");
		baobab_window_message (self, _tmp11_, _tmp12_, GTK_MESSAGE_ERROR);
		_g_free0 (primary);
		_baobab_location_unref0 (location);
		return;
	}
	_tmp13_ = location;
	_tmp14_ = baobab_location_get_info (_tmp13_);
	_tmp15_ = _tmp14_;
	_tmp16_ = g_file_info_get_file_type (_tmp15_);
	if (_tmp16_ != G_FILE_TYPE_DIRECTORY) {
		const gchar* _tmp17_ = NULL;
		GFile* _tmp18_;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_;
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_;
		gchar* primary;
		const gchar* _tmp23_;
		const gchar* _tmp24_ = NULL;
		_tmp17_ = _ ("\"%s\" is not a valid folder");
		_tmp18_ = directory;
		_tmp19_ = g_file_get_parse_name (_tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = g_strdup_printf (_tmp17_, _tmp20_);
		_tmp22_ = _tmp21_;
		_g_free0 (_tmp20_);
		primary = _tmp22_;
		_tmp23_ = primary;
		_tmp24_ = _ ("Could not analyze disk usage.");
		baobab_window_message (self, _tmp23_, _tmp24_, GTK_MESSAGE_ERROR);
		_g_free0 (primary);
		_baobab_location_unref0 (location);
		return;
	}
	_tmp25_ = location;
	baobab_window_set_active_location (self, _tmp25_);
	baobab_window_scan_active_location (self, FALSE);
	_baobab_location_unref0 (location);
}


void baobab_window_action_state_copy (const BaobabWindowActionState* self, BaobabWindowActionState* dest) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gboolean _tmp2_;
	_tmp0_ = (*self).name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).name);
	(*dest).name = _tmp1_;
	_tmp2_ = (*self).enable;
	(*dest).enable = _tmp2_;
}


void baobab_window_action_state_destroy (BaobabWindowActionState* self) {
	_g_free0 ((*self).name);
}


BaobabWindowActionState* baobab_window_action_state_dup (const BaobabWindowActionState* self) {
	BaobabWindowActionState* dup;
	dup = g_new0 (BaobabWindowActionState, 1);
	baobab_window_action_state_copy (self, dup);
	return dup;
}


void baobab_window_action_state_free (BaobabWindowActionState* self) {
	baobab_window_action_state_destroy (self);
	g_free (self);
}


GType baobab_window_action_state_get_type (void) {
	static volatile gsize baobab_window_action_state_type_id__volatile = 0;
	if (g_once_init_enter (&baobab_window_action_state_type_id__volatile)) {
		GType baobab_window_action_state_type_id;
		baobab_window_action_state_type_id = g_boxed_type_register_static ("BaobabWindowActionState", (GBoxedCopyFunc) baobab_window_action_state_dup, (GBoxedFreeFunc) baobab_window_action_state_free);
		g_once_init_leave (&baobab_window_action_state_type_id__volatile, baobab_window_action_state_type_id);
	}
	return baobab_window_action_state_type_id__volatile;
}


static void baobab_window_class_init (BaobabWindowClass * klass) {
	baobab_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BaobabWindowPrivate));
	G_OBJECT_CLASS (klass)->finalize = baobab_window_finalize;
}


static void baobab_window_instance_init (BaobabWindow * self) {
	self->priv = BAOBAB_WINDOW_GET_PRIVATE (self);
}


static void baobab_window_finalize (GObject* obj) {
	BaobabWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BAOBAB_TYPE_WINDOW, BaobabWindow);
	_g_object_unref0 (self->priv->ui_settings);
	_g_object_unref0 (self->priv->header_bar);
	_g_object_unref0 (self->priv->result_header_bar);
	_g_object_unref0 (self->priv->main_stack);
	_g_object_unref0 (self->priv->home_page);
	_g_object_unref0 (self->priv->result_page);
	_g_object_unref0 (self->priv->infobar);
	_g_object_unref0 (self->priv->infobar_primary);
	_g_object_unref0 (self->priv->infobar_secondary);
	_g_object_unref0 (self->priv->location_scroll);
	_g_object_unref0 (self->priv->location_list);
	_g_object_unref0 (self->priv->treeview);
	_g_object_unref0 (self->priv->chart_stack);
	_g_object_unref0 (self->priv->rings_chart);
	_g_object_unref0 (self->priv->treemap_chart);
	_g_object_unref0 (self->priv->spinner);
	_baobab_location_unref0 (self->priv->active_location);
	G_OBJECT_CLASS (baobab_window_parent_class)->finalize (obj);
}


GType baobab_window_get_type (void) {
	static volatile gsize baobab_window_type_id__volatile = 0;
	if (g_once_init_enter (&baobab_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BaobabWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) baobab_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BaobabWindow), 0, (GInstanceInitFunc) baobab_window_instance_init, NULL };
		GType baobab_window_type_id;
		baobab_window_type_id = g_type_register_static (GTK_TYPE_APPLICATION_WINDOW, "BaobabWindow", &g_define_type_info, 0);
		g_once_init_leave (&baobab_window_type_id__volatile, baobab_window_type_id);
	}
	return baobab_window_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



