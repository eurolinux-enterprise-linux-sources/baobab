/* baobab-location-widget.c generated by valac 0.20.1.4-f5a54, the Vala compiler
 * generated from baobab-location-widget.vala, do not modify */

/* -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/* Baobab - disk usage analyzer
 *
 * Copyright (C) 2012  Paolo Borelli <pborelli@gnome.org>
 * Copyright (C) 2012  Stefano Facchini <stefano.facchini@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>


#define BAOBAB_TYPE_LOCATION_WIDGET (baobab_location_widget_get_type ())
#define BAOBAB_LOCATION_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BAOBAB_TYPE_LOCATION_WIDGET, BaobabLocationWidget))
#define BAOBAB_LOCATION_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BAOBAB_TYPE_LOCATION_WIDGET, BaobabLocationWidgetClass))
#define BAOBAB_IS_LOCATION_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAOBAB_TYPE_LOCATION_WIDGET))
#define BAOBAB_IS_LOCATION_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BAOBAB_TYPE_LOCATION_WIDGET))
#define BAOBAB_LOCATION_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BAOBAB_TYPE_LOCATION_WIDGET, BaobabLocationWidgetClass))

typedef struct _BaobabLocationWidget BaobabLocationWidget;
typedef struct _BaobabLocationWidgetClass BaobabLocationWidgetClass;
typedef struct _BaobabLocationWidgetPrivate BaobabLocationWidgetPrivate;

#define BAOBAB_TYPE_LOCATION (baobab_location_get_type ())
#define BAOBAB_LOCATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BAOBAB_TYPE_LOCATION, BaobabLocation))
#define BAOBAB_LOCATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BAOBAB_TYPE_LOCATION, BaobabLocationClass))
#define BAOBAB_IS_LOCATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BAOBAB_TYPE_LOCATION))
#define BAOBAB_IS_LOCATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BAOBAB_TYPE_LOCATION))
#define BAOBAB_LOCATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BAOBAB_TYPE_LOCATION, BaobabLocationClass))

typedef struct _BaobabLocation BaobabLocation;
typedef struct _BaobabLocationClass BaobabLocationClass;
#define _baobab_location_unref0(var) ((var == NULL) ? NULL : (var = (baobab_location_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _BaobabLocationWidget {
	GtkGrid parent_instance;
	BaobabLocationWidgetPrivate * priv;
};

struct _BaobabLocationWidgetClass {
	GtkGridClass parent_class;
};

struct _BaobabLocationWidgetPrivate {
	BaobabLocation* _location;
};


static gpointer baobab_location_widget_parent_class = NULL;
static GtkSizeGroup* baobab_location_widget_name_size_group;
static GtkSizeGroup* baobab_location_widget_name_size_group = NULL;
static GtkSizeGroup* baobab_location_widget_usage_size_group;
static GtkSizeGroup* baobab_location_widget_usage_size_group = NULL;
static GtkIconSize baobab_location_widget_icon_size;
static GtkIconSize baobab_location_widget_icon_size = 0;

GType baobab_location_widget_get_type (void) G_GNUC_CONST;
gpointer baobab_location_ref (gpointer instance);
void baobab_location_unref (gpointer instance);
GParamSpec* baobab_param_spec_location (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void baobab_value_set_location (GValue* value, gpointer v_object);
void baobab_value_take_location (GValue* value, gpointer v_object);
gpointer baobab_value_get_location (const GValue* value);
GType baobab_location_get_type (void) G_GNUC_CONST;
#define BAOBAB_LOCATION_WIDGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), BAOBAB_TYPE_LOCATION_WIDGET, BaobabLocationWidgetPrivate))
enum  {
	BAOBAB_LOCATION_WIDGET_DUMMY_PROPERTY,
	BAOBAB_LOCATION_WIDGET_LOCATION
};
static void baobab_location_widget_ensure_size_groups (BaobabLocationWidget* self);
BaobabLocationWidget* baobab_location_widget_new (BaobabLocation* location_);
BaobabLocationWidget* baobab_location_widget_construct (GType object_type, BaobabLocation* location_);
static void baobab_location_widget_set_location (BaobabLocationWidget* self, BaobabLocation* value);
BaobabLocation* baobab_location_widget_get_location (BaobabLocationWidget* self);
GIcon* baobab_location_get_icon (BaobabLocation* self);
const gchar* baobab_location_get_name (BaobabLocation* self);
GFile* baobab_location_get_file (BaobabLocation* self);
gboolean baobab_location_get_is_volume (BaobabLocation* self);
guint64* baobab_location_get_used (BaobabLocation* self);
guint64* baobab_location_get_size (BaobabLocation* self);
static void baobab_location_widget_finalize (GObject* obj);
static void _vala_baobab_location_widget_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_baobab_location_widget_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static void baobab_location_widget_ensure_size_groups (BaobabLocationWidget* self) {
	GtkSizeGroup* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = baobab_location_widget_name_size_group;
	if (_tmp0_ == NULL) {
		GtkSizeGroup* _tmp1_;
		GtkSizeGroup* _tmp2_;
		GtkIconSize _tmp3_ = 0;
		_tmp1_ = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);
		_g_object_unref0 (baobab_location_widget_name_size_group);
		baobab_location_widget_name_size_group = _tmp1_;
		_tmp2_ = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);
		_g_object_unref0 (baobab_location_widget_usage_size_group);
		baobab_location_widget_usage_size_group = _tmp2_;
		_tmp3_ = gtk_icon_size_register ("baobab", 64, 64);
		baobab_location_widget_icon_size = _tmp3_;
	}
}


BaobabLocationWidget* baobab_location_widget_construct (GType object_type, BaobabLocation* location_) {
	BaobabLocationWidget * self = NULL;
	BaobabLocation* _tmp0_;
	BaobabLocation* _tmp1_;
	GIcon* _tmp2_;
	GIcon* _tmp3_;
	GtkIconSize _tmp4_;
	GtkImage* _tmp5_;
	GtkImage* image;
	GtkImage* _tmp6_;
	GtkImage* _tmp7_;
	BaobabLocation* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	gchar* _tmp11_ = NULL;
	gchar* escaped;
	const gchar* _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	GtkLabel* _tmp15_;
	GtkLabel* _tmp16_;
	GtkLabel* label;
	GtkSizeGroup* _tmp17_;
	GtkLabel* _tmp18_;
	GtkLabel* _tmp19_;
	GtkLabel* _tmp20_;
	GtkLabel* _tmp21_;
	GtkLabel* _tmp22_;
	GtkLabel* _tmp23_;
	GtkLabel* _tmp24_;
	gchar* _tmp25_ = NULL;
	BaobabLocation* _tmp26_;
	GFile* _tmp27_;
	GFile* _tmp28_;
	const gchar* _tmp36_;
	gchar* _tmp37_;
	const gchar* _tmp38_;
	gchar* _tmp39_ = NULL;
	gchar* _tmp40_;
	GtkLabel* _tmp41_;
	GtkSizeGroup* _tmp42_;
	GtkLabel* _tmp43_;
	GtkLabel* _tmp44_;
	GtkLabel* _tmp45_;
	GtkLabel* _tmp46_;
	GtkLabel* _tmp47_;
	GtkLabel* _tmp48_;
	GtkLabel* _tmp49_;
	GtkStyleContext* _tmp50_ = NULL;
	GtkLabel* _tmp51_;
	gboolean _tmp52_ = FALSE;
	gboolean _tmp53_ = FALSE;
	BaobabLocation* _tmp54_;
	gboolean _tmp55_;
	gboolean _tmp56_;
	gboolean _tmp60_;
	gboolean _tmp64_;
	GtkArrow* _tmp103_;
	GtkArrow* _tmp104_;
	g_return_val_if_fail (location_ != NULL, NULL);
	self = (BaobabLocationWidget*) g_object_new (object_type, NULL);
	_tmp0_ = location_;
	baobab_location_widget_set_location (self, _tmp0_);
	gtk_orientable_set_orientation ((GtkOrientable*) self, GTK_ORIENTATION_HORIZONTAL);
	gtk_grid_set_column_spacing ((GtkGrid*) self, 12);
	g_object_set ((GtkWidget*) self, "margin", 6, NULL);
	baobab_location_widget_ensure_size_groups (self);
	_tmp1_ = self->priv->_location;
	_tmp2_ = baobab_location_get_icon (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = baobab_location_widget_icon_size;
	_tmp5_ = (GtkImage*) gtk_image_new_from_gicon (_tmp3_, _tmp4_);
	g_object_ref_sink (_tmp5_);
	image = _tmp5_;
	_tmp6_ = image;
	gtk_image_set_pixel_size (_tmp6_, 64);
	_tmp7_ = image;
	gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) _tmp7_, 0, 0, 1, 2);
	_tmp8_ = self->priv->_location;
	_tmp9_ = baobab_location_get_name (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = g_markup_escape_text (_tmp10_, (gssize) (-1));
	escaped = _tmp11_;
	_tmp12_ = escaped;
	_tmp13_ = g_strdup_printf ("<b>%s</b>", _tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = (GtkLabel*) gtk_label_new (_tmp14_);
	g_object_ref_sink (_tmp15_);
	_tmp16_ = _tmp15_;
	_g_free0 (_tmp14_);
	label = _tmp16_;
	_tmp17_ = baobab_location_widget_name_size_group;
	_tmp18_ = label;
	gtk_size_group_add_widget (_tmp17_, (GtkWidget*) _tmp18_);
	_tmp19_ = label;
	gtk_label_set_use_markup (_tmp19_, TRUE);
	_tmp20_ = label;
	gtk_widget_set_hexpand ((GtkWidget*) _tmp20_, TRUE);
	_tmp21_ = label;
	gtk_widget_set_halign ((GtkWidget*) _tmp21_, GTK_ALIGN_START);
	_tmp22_ = label;
	gtk_widget_set_valign ((GtkWidget*) _tmp22_, GTK_ALIGN_END);
	_tmp23_ = label;
	g_object_set ((GtkMisc*) _tmp23_, "xalign", (gfloat) 0, NULL);
	_tmp24_ = label;
	gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) _tmp24_, 1, 0, 1, 1);
	_tmp26_ = self->priv->_location;
	_tmp27_ = baobab_location_get_file (_tmp26_);
	_tmp28_ = _tmp27_;
	if (_tmp28_ != NULL) {
		BaobabLocation* _tmp29_;
		GFile* _tmp30_;
		GFile* _tmp31_;
		gchar* _tmp32_ = NULL;
		gchar* _tmp33_;
		gchar* _tmp34_ = NULL;
		_tmp29_ = self->priv->_location;
		_tmp30_ = baobab_location_get_file (_tmp29_);
		_tmp31_ = _tmp30_;
		_tmp32_ = g_file_get_parse_name (_tmp31_);
		_tmp33_ = _tmp32_;
		_tmp34_ = g_markup_escape_text (_tmp33_, (gssize) (-1));
		_g_free0 (_tmp25_);
		_tmp25_ = _tmp34_;
		_g_free0 (_tmp33_);
	} else {
		gchar* _tmp35_;
		_tmp35_ = g_strdup ("");
		_g_free0 (_tmp25_);
		_tmp25_ = _tmp35_;
	}
	_tmp36_ = _tmp25_;
	_tmp37_ = g_strdup (_tmp36_);
	_g_free0 (escaped);
	escaped = _tmp37_;
	_tmp38_ = escaped;
	_tmp39_ = g_strdup_printf ("<small>%s</small>", _tmp38_);
	_tmp40_ = _tmp39_;
	_tmp41_ = (GtkLabel*) gtk_label_new (_tmp40_);
	g_object_ref_sink (_tmp41_);
	_g_object_unref0 (label);
	label = _tmp41_;
	_g_free0 (_tmp40_);
	_tmp42_ = baobab_location_widget_name_size_group;
	_tmp43_ = label;
	gtk_size_group_add_widget (_tmp42_, (GtkWidget*) _tmp43_);
	_tmp44_ = label;
	gtk_label_set_use_markup (_tmp44_, TRUE);
	_tmp45_ = label;
	gtk_widget_set_hexpand ((GtkWidget*) _tmp45_, TRUE);
	_tmp46_ = label;
	gtk_widget_set_halign ((GtkWidget*) _tmp46_, GTK_ALIGN_START);
	_tmp47_ = label;
	gtk_widget_set_valign ((GtkWidget*) _tmp47_, GTK_ALIGN_START);
	_tmp48_ = label;
	g_object_set ((GtkMisc*) _tmp48_, "xalign", (gfloat) 0, NULL);
	_tmp49_ = label;
	_tmp50_ = gtk_widget_get_style_context ((GtkWidget*) _tmp49_);
	gtk_style_context_add_class (_tmp50_, "dim-label");
	_tmp51_ = label;
	gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) _tmp51_, 1, 1, 1, 1);
	_tmp54_ = self->priv->_location;
	_tmp55_ = baobab_location_get_is_volume (_tmp54_);
	_tmp56_ = _tmp55_;
	if (_tmp56_) {
		BaobabLocation* _tmp57_;
		guint64* _tmp58_;
		guint64* _tmp59_;
		_tmp57_ = self->priv->_location;
		_tmp58_ = baobab_location_get_used (_tmp57_);
		_tmp59_ = _tmp58_;
		_tmp53_ = _tmp59_ != NULL;
	} else {
		_tmp53_ = FALSE;
	}
	_tmp60_ = _tmp53_;
	if (_tmp60_) {
		BaobabLocation* _tmp61_;
		guint64* _tmp62_;
		guint64* _tmp63_;
		_tmp61_ = self->priv->_location;
		_tmp62_ = baobab_location_get_size (_tmp61_);
		_tmp63_ = _tmp62_;
		_tmp52_ = _tmp63_ != NULL;
	} else {
		_tmp52_ = FALSE;
	}
	_tmp64_ = _tmp52_;
	if (_tmp64_) {
		BaobabLocation* _tmp65_;
		guint64* _tmp66_;
		guint64* _tmp67_;
		gchar* _tmp68_ = NULL;
		gchar* _tmp69_;
		BaobabLocation* _tmp70_;
		guint64* _tmp71_;
		guint64* _tmp72_;
		gchar* _tmp73_ = NULL;
		gchar* _tmp74_;
		gchar* _tmp75_ = NULL;
		gchar* _tmp76_;
		GtkLabel* _tmp77_;
		GtkSizeGroup* _tmp78_;
		GtkLabel* _tmp79_;
		GtkLabel* _tmp80_;
		GtkLabel* _tmp81_;
		GtkLabel* _tmp82_;
		GtkLabel* _tmp83_;
		GtkLevelBar* _tmp84_;
		GtkLevelBar* usagebar;
		GtkSizeGroup* _tmp85_;
		GtkLevelBar* _tmp86_;
		GtkLevelBar* _tmp87_;
		BaobabLocation* _tmp88_;
		guint64* _tmp89_;
		guint64* _tmp90_;
		GtkLevelBar* _tmp91_;
		BaobabLocation* _tmp92_;
		guint64* _tmp93_;
		guint64* _tmp94_;
		GtkLevelBar* _tmp95_;
		BaobabLocation* _tmp96_;
		guint64* _tmp97_;
		guint64* _tmp98_;
		GtkLevelBar* _tmp99_;
		GtkLevelBar* _tmp100_;
		GtkLevelBar* _tmp101_;
		GtkLevelBar* _tmp102_;
		_tmp65_ = self->priv->_location;
		_tmp66_ = baobab_location_get_used (_tmp65_);
		_tmp67_ = _tmp66_;
		_tmp68_ = g_format_size_full (*_tmp67_, G_FORMAT_SIZE_DEFAULT);
		_tmp69_ = _tmp68_;
		_tmp70_ = self->priv->_location;
		_tmp71_ = baobab_location_get_size (_tmp70_);
		_tmp72_ = _tmp71_;
		_tmp73_ = g_format_size_full (*_tmp72_, G_FORMAT_SIZE_DEFAULT);
		_tmp74_ = _tmp73_;
		_tmp75_ = g_strdup_printf ("<small>%s / %s</small>", _tmp69_, _tmp74_);
		_tmp76_ = _tmp75_;
		_tmp77_ = (GtkLabel*) gtk_label_new (_tmp76_);
		g_object_ref_sink (_tmp77_);
		_g_object_unref0 (label);
		label = _tmp77_;
		_g_free0 (_tmp76_);
		_g_free0 (_tmp74_);
		_g_free0 (_tmp69_);
		_tmp78_ = baobab_location_widget_usage_size_group;
		_tmp79_ = label;
		gtk_size_group_add_widget (_tmp78_, (GtkWidget*) _tmp79_);
		_tmp80_ = label;
		gtk_label_set_use_markup (_tmp80_, TRUE);
		_tmp81_ = label;
		gtk_widget_set_halign ((GtkWidget*) _tmp81_, GTK_ALIGN_END);
		_tmp82_ = label;
		gtk_widget_set_valign ((GtkWidget*) _tmp82_, GTK_ALIGN_END);
		_tmp83_ = label;
		gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) _tmp83_, 2, 0, 1, 1);
		_tmp84_ = (GtkLevelBar*) gtk_level_bar_new ();
		g_object_ref_sink (_tmp84_);
		usagebar = _tmp84_;
		_tmp85_ = baobab_location_widget_usage_size_group;
		_tmp86_ = usagebar;
		gtk_size_group_add_widget (_tmp85_, (GtkWidget*) _tmp86_);
		_tmp87_ = usagebar;
		_tmp88_ = self->priv->_location;
		_tmp89_ = baobab_location_get_size (_tmp88_);
		_tmp90_ = _tmp89_;
		gtk_level_bar_set_max_value (_tmp87_, *_tmp90_);
		_tmp91_ = usagebar;
		_tmp92_ = self->priv->_location;
		_tmp93_ = baobab_location_get_size (_tmp92_);
		_tmp94_ = _tmp93_;
		gtk_level_bar_add_offset_value (_tmp91_, GTK_LEVEL_BAR_OFFSET_LOW, 0.9 * (*_tmp94_));
		_tmp95_ = usagebar;
		_tmp96_ = self->priv->_location;
		_tmp97_ = baobab_location_get_used (_tmp96_);
		_tmp98_ = _tmp97_;
		gtk_level_bar_set_value (_tmp95_, *_tmp98_);
		_tmp99_ = usagebar;
		gtk_widget_set_hexpand ((GtkWidget*) _tmp99_, TRUE);
		_tmp100_ = usagebar;
		gtk_widget_set_halign ((GtkWidget*) _tmp100_, GTK_ALIGN_FILL);
		_tmp101_ = usagebar;
		gtk_widget_set_valign ((GtkWidget*) _tmp101_, GTK_ALIGN_START);
		_tmp102_ = usagebar;
		gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) _tmp102_, 2, 1, 1, 1);
		_g_object_unref0 (usagebar);
	}
	_tmp103_ = (GtkArrow*) gtk_arrow_new (GTK_ARROW_RIGHT, GTK_SHADOW_NONE);
	g_object_ref_sink (_tmp103_);
	_tmp104_ = _tmp103_;
	gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) _tmp104_, 3, 0, 1, 2);
	_g_object_unref0 (_tmp104_);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_free0 (_tmp25_);
	_g_object_unref0 (label);
	_g_free0 (escaped);
	_g_object_unref0 (image);
	return self;
}


BaobabLocationWidget* baobab_location_widget_new (BaobabLocation* location_) {
	return baobab_location_widget_construct (BAOBAB_TYPE_LOCATION_WIDGET, location_);
}


BaobabLocation* baobab_location_widget_get_location (BaobabLocationWidget* self) {
	BaobabLocation* result;
	BaobabLocation* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_location;
	result = _tmp0_;
	return result;
}


static gpointer _baobab_location_ref0 (gpointer self) {
	return self ? baobab_location_ref (self) : NULL;
}


static void baobab_location_widget_set_location (BaobabLocationWidget* self, BaobabLocation* value) {
	BaobabLocation* _tmp0_;
	BaobabLocation* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _baobab_location_ref0 (_tmp0_);
	_baobab_location_unref0 (self->priv->_location);
	self->priv->_location = _tmp1_;
	g_object_notify ((GObject *) self, "location");
}


static void baobab_location_widget_class_init (BaobabLocationWidgetClass * klass) {
	baobab_location_widget_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BaobabLocationWidgetPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_baobab_location_widget_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_baobab_location_widget_set_property;
	G_OBJECT_CLASS (klass)->finalize = baobab_location_widget_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), BAOBAB_LOCATION_WIDGET_LOCATION, baobab_param_spec_location ("location", "location", "location", BAOBAB_TYPE_LOCATION, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void baobab_location_widget_instance_init (BaobabLocationWidget * self) {
	self->priv = BAOBAB_LOCATION_WIDGET_GET_PRIVATE (self);
}


static void baobab_location_widget_finalize (GObject* obj) {
	BaobabLocationWidget * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BAOBAB_TYPE_LOCATION_WIDGET, BaobabLocationWidget);
	_baobab_location_unref0 (self->priv->_location);
	G_OBJECT_CLASS (baobab_location_widget_parent_class)->finalize (obj);
}


GType baobab_location_widget_get_type (void) {
	static volatile gsize baobab_location_widget_type_id__volatile = 0;
	if (g_once_init_enter (&baobab_location_widget_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BaobabLocationWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) baobab_location_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BaobabLocationWidget), 0, (GInstanceInitFunc) baobab_location_widget_instance_init, NULL };
		GType baobab_location_widget_type_id;
		baobab_location_widget_type_id = g_type_register_static (GTK_TYPE_GRID, "BaobabLocationWidget", &g_define_type_info, 0);
		g_once_init_leave (&baobab_location_widget_type_id__volatile, baobab_location_widget_type_id);
	}
	return baobab_location_widget_type_id__volatile;
}


static void _vala_baobab_location_widget_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	BaobabLocationWidget * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, BAOBAB_TYPE_LOCATION_WIDGET, BaobabLocationWidget);
	switch (property_id) {
		case BAOBAB_LOCATION_WIDGET_LOCATION:
		baobab_value_set_location (value, baobab_location_widget_get_location (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_baobab_location_widget_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	BaobabLocationWidget * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, BAOBAB_TYPE_LOCATION_WIDGET, BaobabLocationWidget);
	switch (property_id) {
		case BAOBAB_LOCATION_WIDGET_LOCATION:
		baobab_location_widget_set_location (self, baobab_value_get_location (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



